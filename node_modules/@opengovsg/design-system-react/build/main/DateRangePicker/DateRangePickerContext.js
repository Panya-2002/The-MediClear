"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDateRangePicker = exports.DateRangePickerProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("@chakra-ui/react");
const date_fns_1 = require("date-fns");
const useIsMobile_1 = require("../hooks/useIsMobile");
const DateRangePickerContext = (0, react_1.createContext)(null);
const DateRangePickerProvider = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    const value = useProvideDateRangePicker(props);
    return ((0, jsx_runtime_1.jsx)(DateRangePickerContext.Provider, { value: value, children: children }));
};
exports.DateRangePickerProvider = DateRangePickerProvider;
const useDateRangePicker = () => {
    const context = (0, react_1.useContext)(DateRangePickerContext);
    if (!context) {
        throw new Error('useDateRangePicker must be used within a DateRangePickerProvider');
    }
    return context;
};
exports.useDateRangePicker = useDateRangePicker;
const useProvideDateRangePicker = (_a) => {
    var { value, defaultValue = [null, null], onChange, labelSeparator = 'to', displayFormat = 'dd/MM/yyyy', dateFormat = 'dd/MM/yyyy', isDisabled: isDisabledProp, isReadOnly: isReadOnlyProp, isRequired: isRequiredProp, isInvalid: isInvalidProp, timeZone = 'UTC', locale, isDateUnavailable, allowManualInput = true, allowInvalidDates = true, closeCalendarOnChange = true, onBlur, onClick, colorScheme, monthsToDisplay, refocusOnClose = true, size, ssr } = _a, props = __rest(_a, ["value", "defaultValue", "onChange", "labelSeparator", "displayFormat", "dateFormat", "isDisabled", "isReadOnly", "isRequired", "isInvalid", "timeZone", "locale", "isDateUnavailable", "allowManualInput", "allowInvalidDates", "closeCalendarOnChange", "onBlur", "onClick", "colorScheme", "monthsToDisplay", "refocusOnClose", "size", "ssr"]);
    const initialFocusRef = (0, react_1.useRef)(null);
    const startInputRef = (0, react_1.useRef)(null);
    const endInputRef = (0, react_1.useRef)(null);
    const isMobile = (0, useIsMobile_1.useIsMobile)({ ssr });
    const disclosureProps = (0, react_2.useDisclosure)({
        onClose: () => {
            if (!refocusOnClose)
                return;
            // Refocus input after closing calendar.
            setTimeout(() => { var _a; return (_a = endInputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); }, 0);
        },
    });
    const [internalValue, setInternalValue] = (0, react_2.useControllableState)({
        defaultValue,
        value,
        onChange,
    });
    const [startDate, endDate] = internalValue;
    // What is rendered as a string in the start date range input according to given display format.
    const [startInputDisplay, setStartInputDisplay] = (0, react_1.useState)(startDate && (0, date_fns_1.isValid)(startDate)
        ? (0, date_fns_1.format)(startDate, displayFormat, { locale })
        : '');
    // What is rendered as a string in the end date range input according to given display format.
    const [endInputDisplay, setEndInputDisplay] = (0, react_1.useState)(endDate && (0, date_fns_1.isValid)(endDate)
        ? (0, date_fns_1.format)(endDate, displayFormat, { locale })
        : '');
    const handleUpdateInputs = (0, react_1.useCallback)((nextRange) => {
        const sortedRange = nextRange.sort((a, b) => a && b ? a.getTime() - b.getTime() : 0);
        // Replace invalid dates with null
        const validRange = sortedRange.map((date) => (0, date_fns_1.isValid)(date) ? date : null);
        const [nextStart, nextEnd] = sortedRange;
        if (nextStart) {
            if ((0, date_fns_1.isValid)(nextStart)) {
                setStartInputDisplay((0, date_fns_1.format)(nextStart, displayFormat, { locale }));
            }
            else if (!allowInvalidDates) {
                setStartInputDisplay('');
            }
        }
        else {
            setStartInputDisplay('');
        }
        if (nextEnd) {
            if ((0, date_fns_1.isValid)(nextEnd)) {
                setEndInputDisplay((0, date_fns_1.format)(nextEnd, displayFormat, { locale }));
            }
            else if (!allowInvalidDates) {
                setEndInputDisplay('');
            }
        }
        else {
            setEndInputDisplay('');
        }
        setInternalValue(validRange);
    }, [allowInvalidDates, displayFormat, locale, setInternalValue, timeZone]);
    const fcProps = (0, react_2.useFormControlProps)(Object.assign({ isInvalid: isInvalidProp, isDisabled: isDisabledProp, isReadOnly: isReadOnlyProp, isRequired: isRequiredProp }, props));
    const handleInputBlur = (0, react_1.useCallback)((e) => {
        const startDate = (0, date_fns_1.parse)(startInputDisplay, dateFormat, new Date());
        const endDate = (0, date_fns_1.parse)(endInputDisplay, dateFormat, new Date());
        // Clear if input is invalid on blur if invalid dates are not allowed.
        if (!allowInvalidDates && !(0, date_fns_1.isValid)(startDate)) {
            setStartInputDisplay('');
        }
        if (!allowInvalidDates && !(0, date_fns_1.isValid)(endDate)) {
            setEndInputDisplay('');
        }
        handleUpdateInputs([startDate, endDate]);
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    }, [
        startInputDisplay,
        dateFormat,
        endInputDisplay,
        allowInvalidDates,
        handleUpdateInputs,
        onBlur,
    ]);
    const handleInputClick = (0, react_1.useCallback)((e) => {
        e.stopPropagation();
        if (!allowManualInput) {
            disclosureProps.onOpen();
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(e);
    }, [allowManualInput, disclosureProps, onClick]);
    const calendarButtonAria = (0, react_1.useMemo)(() => {
        let ariaLabel = 'Select from date picker. ';
        if (!startDate && !endDate)
            return ariaLabel + 'No date range selected.';
        if (startDate && !endDate) {
            if ((0, date_fns_1.isValid)(startDate)) {
                ariaLabel += `Selected date is ${startDate.toDateString()}.`;
            }
            else {
                ariaLabel += 'Selected start date is invalid.';
            }
            // Both date range exists
        }
        else {
            ariaLabel += `Selected date range is ${startDate === null || startDate === void 0 ? void 0 : startDate.toDateString()} to ${endDate === null || endDate === void 0 ? void 0 : endDate.toDateString()}.`;
        }
        return ariaLabel;
    }, [endDate, startDate]);
    const handleStartDateChange = (event) => {
        const date = (0, date_fns_1.parse)(event.target.value, dateFormat, new Date());
        setStartInputDisplay(event.target.value);
        let clonedValue = [...internalValue];
        if (!(0, date_fns_1.isValid)(date)) {
            if (clonedValue.length > 0) {
                clonedValue = [null, null];
            }
        }
        else {
            clonedValue[0] = date;
        }
        setInternalValue(clonedValue);
    };
    const handleEndDateChange = (event) => {
        const date = (0, date_fns_1.parse)(event.target.value, dateFormat, new Date());
        setEndInputDisplay(event.target.value);
        const [startDate, endDate] = internalValue;
        let clonedValue = [...internalValue];
        if (!(0, date_fns_1.isValid)(date)) {
            if (startDate && endDate) {
                clonedValue = [startDate, null];
            }
        }
        else {
            clonedValue[1] = date;
        }
        setInternalValue(clonedValue);
    };
    const handleCalendarDateChange = (0, react_1.useCallback)((date) => {
        const [nextStartDate, nextEndDate] = date;
        setInternalValue(date);
        setStartInputDisplay(nextStartDate ? (0, date_fns_1.format)(nextStartDate, displayFormat, { locale }) : '');
        setEndInputDisplay(nextEndDate ? (0, date_fns_1.format)(nextEndDate, displayFormat, { locale }) : '');
        if (nextStartDate && nextEndDate && closeCalendarOnChange) {
            disclosureProps.onClose();
        }
    }, [
        closeCalendarOnChange,
        disclosureProps,
        displayFormat,
        locale,
        setInternalValue,
        timeZone,
    ]);
    const handleFieldContainerClick = (0, react_1.useCallback)(() => {
        var _a;
        if (allowManualInput) {
            (_a = startInputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
        else {
            disclosureProps.onOpen();
        }
    }, [allowManualInput, disclosureProps]);
    const styles = (0, react_2.useMultiStyleConfig)('DateRangePicker', {
        size,
        colorScheme,
    });
    const placeholder = (0, react_1.useMemo)(() => displayFormat.toLowerCase(), [displayFormat]);
    return {
        isMobile,
        styles,
        handleCalendarDateChange,
        handleFieldContainerClick,
        handleStartDateChange,
        handleEndDateChange,
        handleInputClick,
        calendarButtonAria,
        startInputRef,
        endInputRef,
        initialFocusRef,
        handleInputBlur,
        fcProps,
        internalValue,
        startInputDisplay,
        endInputDisplay,
        closeCalendarOnChange,
        placeholder,
        allowManualInput,
        colorScheme,
        size,
        isDateUnavailable,
        disclosureProps,
        labelSeparator,
        monthsToDisplay,
    };
};
