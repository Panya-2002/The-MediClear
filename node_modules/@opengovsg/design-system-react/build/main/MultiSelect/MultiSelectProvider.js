"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSelectProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("@chakra-ui/react");
const downshift_1 = require("downshift");
const SingleSelect_1 = require("../SingleSelect");
const constants_1 = require("../SingleSelect/constants");
const useItems_1 = require("../SingleSelect/hooks/useItems");
const utils_1 = require("../SingleSelect/utils");
const MultiSelectContext_1 = require("./MultiSelectContext");
const MultiSelectProvider = ({ items: rawItems, values, onChange, name, filter = utils_1.defaultFilter, nothingFoundLabel = 'No matching results', placeholder: placeholderProp, clearButtonLabel = 'Clear selection', isSearchable = true, defaultIsOpen, isInvalid: isInvalidProp, isReadOnly: isReadOnlyProp, isDisabled: isDisabledProp, isRequired: isRequiredProp, maxItems = 4, downshiftComboboxProps = {}, downshiftMultiSelectProps = {}, inputAria, children, size: _size, colorScheme, }) => {
    var _a, _b, _c, _d;
    const theme = (0, react_2.useTheme)();
    // Required in case size is set in theme, we should respect the one set in theme.
    const size = (0, react_1.useMemo)(() => {
        var _a, _b, _c, _d;
        return ((_d = _size !== null && _size !== void 0 ? _size : (_c = (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.components) === null || _a === void 0 ? void 0 : _a.MultiSelect) === null || _b === void 0 ? void 0 : _b.defaultProps) === null || _c === void 0 ? void 0 : _c.size) !== null && _d !== void 0 ? _d : 'md');
    }, [_size, (_c = (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.components) === null || _a === void 0 ? void 0 : _a.MultiSelect) === null || _b === void 0 ? void 0 : _b.defaultProps) === null || _c === void 0 ? void 0 : _c.size]);
    const { items, getItemByValue } = (0, useItems_1.useItems)({ rawItems });
    const [isFocused, setIsFocused] = (0, react_1.useState)(false);
    // Inject for components to manipulate
    const inputRef = (0, react_1.useRef)(null);
    const virtualListRef = (0, react_1.useRef)(null);
    const { isInvalid, isDisabled, isReadOnly, isRequired } = (0, react_2.useFormControlProps)({
        isInvalid: isInvalidProp,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        isRequired: isRequiredProp,
    });
    const getFilteredItems = (0, react_1.useCallback)((filterValue) => {
        return filterValue ? filter(items, filterValue) : items;
    }, [filter, items]);
    const [filteredItems, setFilteredItems] = (0, react_1.useState)(getFilteredItems((_d = downshiftComboboxProps.initialInputValue) !== null && _d !== void 0 ? _d : downshiftComboboxProps.inputValue));
    const selectedItems = (0, react_1.useMemo)(() => {
        const items = [];
        for (const value of values) {
            const item = getItemByValue(value);
            if (item) {
                items.push(item.item);
            }
        }
        return items;
    }, [getItemByValue, values]);
    const { getSelectedItemProps, getDropdownProps, addSelectedItem, removeSelectedItem, reset, activeIndex, setActiveIndex, } = (0, downshift_1.useMultipleSelection)(Object.assign({ selectedItems, onSelectedItemsChange: ({ selectedItems }) => {
            var _a;
            onChange((_a = selectedItems === null || selectedItems === void 0 ? void 0 : selectedItems.filter((item) => !(0, utils_1.isItemDisabled)(item)).map(utils_1.itemToValue)) !== null && _a !== void 0 ? _a : []);
        }, itemToString: utils_1.itemToLabelString, stateReducer: (_state, { changes, type }) => {
            switch (type) {
                case downshift_1.useMultipleSelection.stateChangeTypes.FunctionRemoveSelectedItem:
                    return Object.assign(Object.assign({}, changes), { 
                        // The focus will move to the input/button
                        // This prevents a bug where the focus would move to a selected item
                        // when deselecting a selected item in the dropdown.
                        activeIndex: -1 });
                default:
                    return changes;
            }
        } }, downshiftMultiSelectProps));
    const dynamicPlaceholder = (0, react_1.useMemo)(() => {
        if (placeholderProp === null || selectedItems.length > 0)
            return '';
        return placeholderProp !== null && placeholderProp !== void 0 ? placeholderProp : 'Select options';
    }, [placeholderProp, selectedItems.length]);
    const { toggleMenu, closeMenu, isOpen, getLabelProps, getMenuProps, getInputProps, getItemProps, getToggleButtonProps, selectItem, inputValue, highlightedIndex, setInputValue, } = (0, downshift_1.useCombobox)(Object.assign({ labelId: `${name}-label`, inputId: name, items: filteredItems, itemToString: utils_1.itemToLabelString, defaultIsOpen, defaultInputValue: '', defaultHighlightedIndex: 0, 
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        scrollIntoView: () => { }, onHighlightedIndexChange: ({ highlightedIndex }) => {
            if (highlightedIndex !== undefined &&
                highlightedIndex >= 0 &&
                virtualListRef.current) {
                virtualListRef.current.scrollIntoView({
                    index: highlightedIndex,
                });
            }
        }, onStateChange: ({ inputValue, type }) => {
            switch (type) {
                case downshift_1.useCombobox.stateChangeTypes.FunctionSetInputValue:
                case downshift_1.useCombobox.stateChangeTypes.InputChange:
                    setFilteredItems(getFilteredItems(inputValue));
                    break;
                default:
                    return;
            }
        }, stateReducer: (state, { changes, type }) => {
            switch (type) {
                case downshift_1.useCombobox.stateChangeTypes.InputKeyDownEnter:
                case downshift_1.useCombobox.stateChangeTypes.ItemClick: {
                    const { selectedItem } = changes;
                    if (selectedItem) {
                        if (selectedItems.includes(selectedItem)) {
                            removeSelectedItem(selectedItem);
                        }
                        else {
                            addSelectedItem(selectedItem);
                        }
                    }
                    return Object.assign(Object.assign({}, changes), { 
                        // Retain previous inputValue
                        inputValue: state.inputValue, 
                        // Keep highlighted index the same.
                        highlightedIndex: state.highlightedIndex, selectedItem: null, 
                        // Keep the menu open after selection.
                        isOpen: true });
                }
                case downshift_1.useCombobox.stateChangeTypes.InputBlur:
                    setFilteredItems(getFilteredItems());
                    // Clear input regardless on blur.
                    return Object.assign(Object.assign({}, changes), { inputValue: '', isOpen: false });
                case downshift_1.useCombobox.stateChangeTypes.InputFocus:
                    return Object.assign(Object.assign({}, changes), { isOpen: false });
                case downshift_1.useCombobox.stateChangeTypes.ToggleButtonClick:
                    return Object.assign(Object.assign({}, changes), { isOpen: !state.isOpen });
                default:
                    return changes;
            }
        } }, downshiftComboboxProps));
    /** Effect to update filtered items whenever items prop changes. */
    (0, react_1.useEffect)(() => {
        setFilteredItems(getFilteredItems(inputValue));
    }, [getFilteredItems, inputValue, items]);
    const resetInputValue = (0, react_1.useCallback)(() => setInputValue(''), [setInputValue]);
    const isItemSelected = (0, react_1.useCallback)((item) => {
        return selectedItems.includes(item);
    }, [selectedItems]);
    const styles = (0, react_2.useMultiStyleConfig)('MultiSelect', {
        size,
        isFocused: isFocused || isOpen,
        isEmpty: selectedItems.length === 0,
    });
    const virtualListHeight = (0, react_1.useMemo)(() => {
        const totalHeight = filteredItems.length * constants_1.VIRTUAL_LIST_ITEM_HEIGHT[size];
        // If the total height is less than the max height, just return the total height.
        // Otherwise, return the max height.
        return Math.min(totalHeight, constants_1.VIRTUAL_LIST_MAX_HEIGHT[size]);
    }, [filteredItems.length, size]);
    return ((0, jsx_runtime_1.jsx)(SingleSelect_1.SelectContext.Provider, { value: {
            size,
            inputRef,
            isClearable: false,
            selectedItem: null,
            isOpen,
            isItemSelected,
            toggleMenu,
            closeMenu,
            getInputProps,
            getItemProps,
            getLabelProps,
            getMenuProps,
            getToggleButtonProps,
            selectItem,
            highlightedIndex,
            items: filteredItems,
            nothingFoundLabel,
            inputValue,
            isSearchable,
            name,
            clearButtonLabel,
            placeholder: dynamicPlaceholder,
            styles,
            isFocused,
            setIsFocused,
            isInvalid,
            isDisabled,
            isReadOnly,
            isRequired,
            resetInputValue,
            inputAria,
            virtualListRef,
            virtualListHeight,
        }, children: (0, jsx_runtime_1.jsx)(MultiSelectContext_1.MultiSelectContext.Provider, { value: {
                selectedItems,
                getDropdownProps,
                getSelectedItemProps,
                addSelectedItem,
                removeSelectedItem,
                reset,
                maxItems,
                activeIndex,
                setActiveIndex,
                colorScheme,
            }, children: children }) }));
};
exports.MultiSelectProvider = MultiSelectProvider;
