"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDatePicker = exports.DatePickerProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("@chakra-ui/react");
const date_fns_1 = require("date-fns");
const hooks_1 = require("../hooks");
const DatePickerContext = (0, react_1.createContext)(null);
const DatePickerProvider = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    const value = useProvideDatePicker(props);
    return ((0, jsx_runtime_1.jsx)(DatePickerContext.Provider, { value: value, children: children }));
};
exports.DatePickerProvider = DatePickerProvider;
const useDatePicker = () => {
    const context = (0, react_1.useContext)(DatePickerContext);
    if (!context) {
        throw new Error('useDatePicker must be used within a DatePickerProvider');
    }
    return context;
};
exports.useDatePicker = useDatePicker;
const useProvideDatePicker = (_a) => {
    var { value, defaultValue, onChange, inputValue, defaultInputValue, onInputValueChange, displayFormat = 'dd/MM/yyyy', dateFormat = 'dd/MM/yyyy', isDisabled: isDisabledProp, isReadOnly: isReadOnlyProp, isRequired: isRequiredProp, isInvalid: isInvalidProp, locale, isDateUnavailable, allowManualInput = true, allowInvalidDates = true, closeCalendarOnChange = true, onBlur, onClick, colorScheme, monthsToDisplay, refocusOnClose = true, ssr, size, defaultFocusedDate } = _a, props = __rest(_a, ["value", "defaultValue", "onChange", "inputValue", "defaultInputValue", "onInputValueChange", "displayFormat", "dateFormat", "isDisabled", "isReadOnly", "isRequired", "isInvalid", "locale", "isDateUnavailable", "allowManualInput", "allowInvalidDates", "closeCalendarOnChange", "onBlur", "onClick", "colorScheme", "monthsToDisplay", "refocusOnClose", "ssr", "size", "defaultFocusedDate"]);
    const initialFocusRef = (0, react_1.useRef)(null);
    const inputRef = (0, react_1.useRef)(null);
    const isMobile = (0, hooks_1.useIsMobile)({ ssr });
    const disclosureProps = (0, react_2.useDisclosure)({
        onClose: () => {
            if (!refocusOnClose)
                return;
            // Refocus input after closing calendar.
            setTimeout(() => { var _a; return (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); }, 0);
        },
    });
    // Date typed values of the input.
    const [internalValue, setInternalValue] = (0, react_2.useControllableState)({
        defaultValue,
        value,
        onChange,
    });
    const formatInputValue = (0, react_1.useCallback)((date) => {
        if (!date || !(0, date_fns_1.isValid)(date))
            return '';
        return (0, date_fns_1.format)(date, displayFormat, { locale });
    }, [displayFormat, locale]);
    // What is rendered as a string in the input according to given display format.
    const [internalInputValue, setInternalInputValue] = (0, react_2.useControllableState)({
        defaultValue: defaultInputValue !== null && defaultInputValue !== void 0 ? defaultInputValue : formatInputValue(internalValue),
        value: inputValue,
        onChange: onInputValueChange,
    });
    const fcProps = (0, react_2.useFormControlProps)(Object.assign({ isInvalid: isInvalidProp, isDisabled: isDisabledProp, isReadOnly: isReadOnlyProp, isRequired: isRequiredProp }, props));
    const handleInputBlur = (0, react_1.useCallback)((e) => {
        const date = (0, date_fns_1.parse)(internalInputValue, dateFormat, new Date());
        // Clear if input is invalid on blur if invalid dates are not allowed.
        if (!allowInvalidDates && !(0, date_fns_1.isValid)(date)) {
            setInternalValue(null);
            setInternalInputValue('');
        }
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    }, [
        allowInvalidDates,
        dateFormat,
        internalInputValue,
        onBlur,
        setInternalInputValue,
        setInternalValue,
    ]);
    const calendarButtonAria = (0, react_1.useMemo)(() => {
        let ariaLabel = 'Select from date picker. ';
        if (internalValue) {
            if ((0, date_fns_1.isValid)(internalValue)) {
                ariaLabel += `Selected date is ${internalValue.toLocaleDateString()}.`;
            }
            else {
                ariaLabel += 'The current selected date is invalid.';
            }
        }
        return ariaLabel;
    }, [internalValue]);
    const handleDateChange = (0, react_1.useCallback)((date) => {
        if (allowInvalidDates || (0, date_fns_1.isValid)(date) || !date) {
            setInternalValue(date);
        }
        if (date) {
            setInternalInputValue((0, date_fns_1.format)(date, displayFormat, { locale }));
        }
        else {
            setInternalInputValue('');
        }
        closeCalendarOnChange && disclosureProps.onClose();
    }, [
        allowInvalidDates,
        closeCalendarOnChange,
        disclosureProps,
        displayFormat,
        locale,
        setInternalInputValue,
        setInternalValue,
    ]);
    const handleInputChange = (0, react_1.useCallback)((event) => {
        const date = (0, date_fns_1.parse)(event.target.value, dateFormat, new Date());
        setInternalInputValue(event.target.value);
        if ((0, date_fns_1.isValid)(date)) {
            setInternalValue(date);
        }
    }, [dateFormat, setInternalInputValue, setInternalValue]);
    const handleInputClick = (0, react_1.useCallback)((e) => {
        if (!allowManualInput) {
            e.stopPropagation();
            disclosureProps.onOpen();
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(e);
    }, [allowManualInput, disclosureProps, onClick]);
    const styles = (0, react_2.useMultiStyleConfig)('DatePicker', {
        size,
        colorScheme,
    });
    const placeholder = (0, react_1.useMemo)(() => displayFormat.toLowerCase(), [displayFormat]);
    return {
        isMobile,
        styles,
        handleInputChange,
        handleInputClick,
        handleDateChange,
        calendarButtonAria,
        inputRef,
        initialFocusRef,
        handleInputBlur,
        fcProps,
        internalInputValue,
        internalValue,
        closeCalendarOnChange,
        placeholder,
        allowManualInput,
        colorScheme,
        size,
        isDateUnavailable,
        disclosureProps,
        monthsToDisplay,
        defaultFocusedDate,
    };
};
