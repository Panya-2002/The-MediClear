"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Attachment = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_dropzone_1 = require("react-dropzone");
const react_2 = require("@chakra-ui/react");
const utils_1 = require("@chakra-ui/utils");
const lodash_1 = require("lodash");
const AttachmentContext_1 = require("./AttachmentContext");
const AttachmentDropzone_1 = require("./AttachmentDropzone");
const AttachmentFileInfo_1 = require("./AttachmentFileInfo");
const utils_2 = require("./utils");
exports.Attachment = (0, react_2.forwardRef)((_a, ref) => {
    var { onChange, onError, maxSize, showFileSize, accept, value, name, colorScheme, imagePreview, onFileValidation } = _a, props = __rest(_a, ["onChange", "onError", "maxSize", "showFileSize", "accept", "value", "name", "colorScheme", "imagePreview", "onFileValidation"]);
    // Merge given props with any form control props, if they exist.
    const inputProps = (0, react_2.useFormControl)(props);
    // id to set on the rendered max size FormHelperText component.
    const maxSizeTextId = (0, react_1.useMemo)(() => `${name}-max-size`, [name]);
    const readableMaxSize = (0, react_1.useMemo)(() => (maxSize ? (0, utils_2.getReadableFileSize)(maxSize) : undefined), [maxSize]);
    const showMaxSize = (0, react_1.useMemo)(() => !value && showFileSize && readableMaxSize, [value, readableMaxSize, showFileSize]);
    const ariaDescribedBy = (0, react_1.useMemo)(() => {
        var _a;
        const describedByIds = new Set();
        // Must be in this order so the screen reader reads out something coherent.
        // 1. Label text (if available)
        // 2. Initial describedby text (if available)
        // 3. Max size text (if prop is true)
        if (inputProps.id) {
            describedByIds.add(`${inputProps.id}-label`);
        }
        (_a = inputProps['aria-describedby']) === null || _a === void 0 ? void 0 : _a.split(' ').map((id) => describedByIds.add(id));
        if (showMaxSize) {
            describedByIds.add(maxSizeTextId);
        }
        // Remove helptext, since label should already consist of the text
        describedByIds.delete(`${inputProps.id}-helptext`);
        return Array.from(describedByIds).filter(Boolean).join(' ').trim();
    }, [inputProps, maxSizeTextId, showMaxSize]);
    const handleFileDrop = (0, react_1.useCallback)(async ([acceptedFile], rejectedFiles) => {
        if (rejectedFiles.length > 0) {
            const firstError = rejectedFiles[0].errors[0];
            let errorMessage;
            switch (firstError.code) {
                case 'file-invalid-type': {
                    const fileExt = (0, utils_2.getFileExtension)(rejectedFiles[0].file.name);
                    errorMessage = `Your file's extension ending in *${fileExt} is not allowed`;
                    break;
                }
                case 'too-many-files': {
                    errorMessage = 'You can only upload a single file in this input';
                    break;
                }
                default:
                    errorMessage = firstError.message;
            }
            return onError === null || onError === void 0 ? void 0 : onError(errorMessage);
        }
        const fileValidationErrorMessage = await (onFileValidation === null || onFileValidation === void 0 ? void 0 : onFileValidation(acceptedFile));
        if (fileValidationErrorMessage) {
            return onError === null || onError === void 0 ? void 0 : onError(fileValidationErrorMessage);
        }
        onChange(acceptedFile);
    }, [onChange, onError, onFileValidation]);
    const fileValidator = (0, react_1.useCallback)((file) => {
        if (maxSize && file.size > maxSize) {
            return {
                code: 'file-too-large',
                message: `You have exceeded the limit, please upload a file below ${readableMaxSize}`,
            };
        }
        return null;
    }, [maxSize, readableMaxSize]);
    const { getRootProps, getInputProps, isDragActive, rootRef } = (0, react_dropzone_1.useDropzone)({
        multiple: false,
        accept,
        disabled: inputProps.disabled,
        validator: fileValidator,
        noClick: inputProps.readOnly,
        noDrag: inputProps.readOnly,
        onDrop: handleFileDrop,
    });
    const mergedRefs = (0, react_2.useMergeRefs)(rootRef, ref);
    const styles = (0, react_2.useMultiStyleConfig)('Attachment', {
        isDragActive,
        colorScheme,
        imagePreview,
    });
    const handleRemoveFile = (0, react_1.useCallback)(() => {
        var _a;
        onChange(undefined);
        (_a = rootRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [onChange, rootRef]);
    // Bunch of memoization to avoid unnecessary re-renders.
    const processedRootProps = (0, react_1.useMemo)(() => {
        return getRootProps(Object.assign(Object.assign({}, (0, lodash_1.omit)(inputProps, 'id')), { 
            // Bunch of extra work to prevent field from being used when in readOnly
            // state.
            onKeyDown: (e) => {
                if (inputProps.readOnly) {
                    e.stopPropagation();
                    return;
                }
            }, 'aria-describedby': ariaDescribedBy }));
    }, [ariaDescribedBy, getRootProps, inputProps]);
    const processedInputProps = (0, react_1.useMemo)(() => {
        return getInputProps(Object.assign({ name }, inputProps));
    }, [getInputProps, inputProps, name]);
    return ((0, jsx_runtime_1.jsx)(AttachmentContext_1.AttachmentStylesProvider, { value: styles, children: (0, jsx_runtime_1.jsxs)(react_2.Box, { __css: styles.container, children: [(0, jsx_runtime_1.jsx)(react_2.Box, Object.assign({}, processedRootProps, { ref: mergedRefs, "data-active": (0, utils_1.dataAttr)(isDragActive), __css: value ? undefined : styles.dropzone, children: value ? ((0, jsx_runtime_1.jsx)(AttachmentFileInfo_1.AttachmentFileInfo, { file: value, imagePreview: imagePreview, handleRemoveFile: handleRemoveFile, isDisabled: inputProps.disabled, isReadOnly: inputProps.readOnly })) : ((0, jsx_runtime_1.jsx)(AttachmentDropzone_1.AttachmentDropzone, { isDragActive: isDragActive, inputProps: processedInputProps })) })), showMaxSize ? ((0, jsx_runtime_1.jsxs)(react_2.Text, { id: maxSizeTextId, color: "base.content.medium", mt: "0.5rem", textStyle: "body-2", children: ["Maximum file size: ", readableMaxSize] })) : null] }) }));
});
exports.Attachment.displayName = 'Attachment';
