"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalendarHeader = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("@chakra-ui/react");
const date_fns_1 = require("date-fns");
const IconButton_1 = require("../../IconButton");
const icons_1 = require("../../icons");
const CalendarContext_1 = require("./CalendarContext");
const CalendarStyleProvider_1 = require("./CalendarStyleProvider");
const utils_1 = require("./utils");
const MonthYearSelect = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    const styles = (0, CalendarStyleProvider_1.useCalendarStyles)();
    return ((0, jsx_runtime_1.jsx)(react_2.Select
    // Prevents any parent form control from applying error styles to this select.
    , Object.assign({ 
        // Prevents any parent form control from applying error styles to this select.
        isInvalid: false, variant: "flushed", flexBasis: "fit-content", sx: styles.monthYearSelect }, props, { children: children })));
};
const SelectableMonthYear = (0, react_1.memo)(() => {
    const { currMonth, setCurrMonth, currYear, setCurrYear, yearOptions, isMobile, } = (0, CalendarContext_1.useCalendar)();
    const memoizedMonthOptions = (0, react_1.useMemo)(() => {
        return utils_1.MONTH_NAMES.map(({ shortName, fullName }, index) => ((0, jsx_runtime_1.jsx)("option", { value: index, children: isMobile ? shortName : fullName }, index)));
    }, [isMobile]);
    const memoizedYearOptions = (0, react_1.useMemo)(() => {
        return yearOptions.map((year, index) => ((0, jsx_runtime_1.jsx)("option", { value: year, children: year }, index)));
    }, [yearOptions]);
    const handleMonthChange = (0, react_1.useCallback)((e) => {
        setCurrMonth(parseInt(e.target.value));
    }, [setCurrMonth]);
    const handleYearChange = (0, react_1.useCallback)((e) => {
        setCurrYear(parseInt(e.target.value));
    }, [setCurrYear]);
    return ((0, jsx_runtime_1.jsxs)(react_2.HStack, { children: [(0, jsx_runtime_1.jsx)(MonthYearSelect, { value: currMonth, onChange: handleMonthChange, "aria-label": "Change displayed month", children: memoizedMonthOptions }), (0, jsx_runtime_1.jsx)(MonthYearSelect, { value: currYear, onChange: handleYearChange, "aria-label": "Change displayed year", children: memoizedYearOptions })] }));
});
const MonthYear = (0, react_1.memo)(({ monthOffset }) => {
    const { currMonth, currYear, isMobile } = (0, CalendarContext_1.useCalendar)();
    const styles = (0, CalendarStyleProvider_1.useCalendarStyles)();
    const newOffsetDate = (0, react_1.useMemo)(() => (0, date_fns_1.addMonths)(new Date(currYear, currMonth), monthOffset), [currMonth, currYear, monthOffset]);
    const monthDisplay = (0, react_1.useMemo)(() => {
        const month = utils_1.MONTH_NAMES[newOffsetDate.getMonth()];
        return isMobile ? month.shortName : month.fullName;
    }, [isMobile, newOffsetDate]);
    const yearDisplay = (0, react_1.useMemo)(() => {
        return newOffsetDate.getFullYear();
    }, [newOffsetDate]);
    return ((0, jsx_runtime_1.jsxs)(react_2.HStack, { sx: styles.monthYearDisplay, children: [(0, jsx_runtime_1.jsx)(react_2.Text, { children: monthDisplay }), (0, jsx_runtime_1.jsx)(react_2.Text, { children: yearDisplay })] }));
});
exports.CalendarHeader = (0, react_1.memo)(({ monthOffset }) => {
    const styles = (0, CalendarStyleProvider_1.useCalendarStyles)();
    const { renderProps: { calendars, getBackProps, getForwardProps }, size, } = (0, CalendarContext_1.useCalendar)();
    return ((0, jsx_runtime_1.jsxs)(react_2.Flex, { sx: styles.monthYearSelectorContainer, children: [monthOffset === 0 ? ((0, jsx_runtime_1.jsx)(SelectableMonthYear, {})) : ((0, jsx_runtime_1.jsx)(MonthYear, { monthOffset: monthOffset })), calendars.length - 1 === monthOffset ? ((0, jsx_runtime_1.jsxs)(react_2.Flex, { sx: styles.monthArrowContainer, children: [(0, jsx_runtime_1.jsx)(IconButton_1.IconButton, Object.assign({ variant: "clear", colorScheme: "neutral", size: size, icon: (0, jsx_runtime_1.jsx)(icons_1.BxChevronLeft, {}), "aria-label": "Back one month" }, getBackProps({ calendars }))), (0, jsx_runtime_1.jsx)(IconButton_1.IconButton, Object.assign({ variant: "clear", colorScheme: "neutral", size: size, icon: (0, jsx_runtime_1.jsx)(icons_1.BxChevronRight, {}), "aria-label": "Forward one month" }, getForwardProps({ calendars })))] })) : null] }));
});
