"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCalendar = exports.CalendarProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const date_fns_1 = require("date-fns");
const dayzed_1 = require("dayzed");
const lodash_1 = require("lodash");
const non_secure_1 = require("nanoid/non-secure");
const rooks_1 = require("rooks");
const hooks_1 = require("../../hooks");
const utils_1 = require("./utils");
const ARROW_KEY_NAMES = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
// Removed - and _ from alphabets for simpler classnames
const nanoid = (0, non_secure_1.customAlphabet)('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 16);
const CalendarContext = (0, react_1.createContext)(undefined);
const CalendarProvider = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    const value = useProvideCalendar(props);
    return ((0, jsx_runtime_1.jsx)(CalendarContext.Provider, { value: value, children: children }));
};
exports.CalendarProvider = CalendarProvider;
const useCalendar = () => {
    const context = (0, react_1.useContext)(CalendarContext);
    if (!context) {
        throw new Error('useCalendar must be used within a CalendarProvider');
    }
    return context;
};
exports.useCalendar = useCalendar;
const useProvideCalendar = ({ selectedDates, onSelectDate, isDateUnavailable, monthsToDisplay = 1, onMouseEnterHighlight, onMouseLeaveCalendar, isDateInRange, hoveredDate, colorScheme, size, ssr, defaultFocusedDate, }) => {
    const isMobile = (0, hooks_1.useIsMobile)({ ssr });
    // Ensure that calculations are always made based on date of initial render,
    // so component state doesn't suddenly jump at midnight
    const today = (0, react_1.useMemo)(() => new Date(), []);
    // Unique className for dates
    const classNameId = (0, react_1.useMemo)(() => nanoid(), []);
    const yearOptions = (0, react_1.useMemo)(() => (0, utils_1.getYearOptions)(), []);
    // Date to focus on initial render if initialFocusRef is passed
    const dateToFocus = (0, react_1.useMemo)(() => {
        if (Array.isArray(selectedDates) && selectedDates[0]) {
            return selectedDates[0];
        }
        if (selectedDates instanceof Date) {
            return selectedDates;
        }
        return defaultFocusedDate !== null && defaultFocusedDate !== void 0 ? defaultFocusedDate : today;
    }, [today, selectedDates, defaultFocusedDate]);
    const [currMonth, setCurrMonth] = (0, react_1.useState)(dateToFocus.getMonth());
    const [currYear, setCurrYear] = (0, react_1.useState)(dateToFocus.getFullYear());
    /**
     * Updates the current year and month when the forward/back arrows are clicked.
     * We need to pass this to Dayzed because we want to control the current year
     * and month via both the dropdowns and arrows.
     */
    const onOffsetChanged = (0, react_1.useCallback)((offset) => {
        const newDate = (0, date_fns_1.addMonths)(today, offset);
        setCurrYear(newDate.getFullYear());
        setCurrMonth(newDate.getMonth());
    }, [today]);
    /**
     * Handles user clicking on "Today" at bottom of datepicker
     */
    const handleTodayClick = (0, react_1.useCallback)(() => {
        // Get most updated "today", rather than "today" at the point
        // of component rendering
        const today = new Date();
        setCurrMonth(today.getMonth());
        setCurrYear(today.getFullYear());
        // Workaround to ensure that the correct element is in the DOM
        // before running document.querySelector
        setTimeout(() => {
            const elementToFocus = document.querySelector(`.${(0, utils_1.generateClassNameForDate)(classNameId, today)}`);
            elementToFocus === null || elementToFocus === void 0 ? void 0 : elementToFocus.focus();
        });
    }, [classNameId]);
    const updateMonthYear = (0, react_1.useCallback)((newDate) => {
        const monthDiff = (0, date_fns_1.differenceInCalendarMonths)(newDate, new Date(currYear, currMonth));
        if (monthDiff < 0 || monthDiff > monthsToDisplay - 1) {
            setCurrMonth(newDate.getMonth());
            setCurrYear(newDate.getFullYear());
        }
    }, [currMonth, currYear, monthsToDisplay]);
    /**
     * Allows user to change focus across rows/columns using arrow keys. The
     * idea is to attach a unique classname to each day, from which we can derive
     * the date which it corresponds to.
     * This function implements an effect where using the arrow key to move
     * to dates outside the current month (i.e. the greyed-out dates from the previous
     * and next months) will cause the datepicker to scroll to that month. However,
     * note that we DO NOT want this effect to happen for tabs too, as this would mean
     * the user can never tab outside the datepicker.
     */
    const handleArrowKey = (0, react_1.useCallback)((e) => {
        const currentlyFocused = document.activeElement;
        if (!currentlyFocused ||
            !currentlyFocused.className.includes(classNameId)) {
            return;
        }
        const focusedDate = (0, utils_1.getDateFromClassName)(currentlyFocused.className, classNameId);
        if (!focusedDate)
            return;
        // Prevent arrow key from scrolling screen
        e.preventDefault();
        const newDate = (0, utils_1.getNewDateFromKeyPress)(focusedDate, e.key);
        if (newDate === focusedDate)
            return;
        // If newDate is outside current displayed months, scroll to that month
        updateMonthYear(newDate);
        // setTimeout is required so focusing happens after the DOM has updated.
        setTimeout(() => {
            const elementToFocus = document.querySelector(`.${(0, utils_1.generateClassNameForDate)(classNameId, newDate)}`);
            elementToFocus === null || elementToFocus === void 0 ? void 0 : elementToFocus.focus();
        }, 0);
    }, [updateMonthYear, classNameId]);
    (0, rooks_1.useKey)(ARROW_KEY_NAMES, handleArrowKey);
    const handleDateSelected = (0, react_1.useCallback)((d) => {
        if (isDateUnavailable === null || isDateUnavailable === void 0 ? void 0 : isDateUnavailable(d))
            return;
        // Set current month/year to that of selected
        updateMonthYear(d);
        // Call parent callback
        onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(d);
    }, [isDateUnavailable, onSelectDate, updateMonthYear]);
    const renderProps = (0, dayzed_1.useDayzed)({
        date: today,
        onDateSelected: ({ date }) => handleDateSelected(date),
        showOutsideDays: monthsToDisplay === 1,
        offset: (0, utils_1.getMonthOffsetFromToday)(today, currMonth, currYear),
        onOffsetChanged,
        selected: !Array.isArray(selectedDates)
            ? selectedDates
            : selectedDates.filter(Boolean),
        monthsToDisplay: monthsToDisplay,
    });
    /**
     * Determines whether a given date should be in the tabbing sequence.
     * We only want one date at a time to be in the tabbing sequence.
     */
    const isDateFocusable = (0, react_1.useCallback)((d) => {
        // If there is a selected date in the current month, make it
        // the only focusable date
        if (dateToFocus &&
            (0, lodash_1.inRange)(dateToFocus.getMonth(), currMonth, currMonth + monthsToDisplay)) {
            return (0, date_fns_1.isSameDay)(d, dateToFocus);
        }
        // If today is in the current month, make it the only focusable date
        // Use the latest today instead of memoised today since this doesn't affect
        // offset logic
        const currentToday = new Date();
        if (currentToday.getMonth() === currMonth) {
            return (0, date_fns_1.isSameDay)(d, currentToday);
        }
        // If current month does not contain selected or today, make
        // first day focusable. We need to check that it corresponds with
        // currMonth or the spillover dates for the next month will be included.
        return d.getMonth() === currMonth && (0, date_fns_1.isFirstDayOfMonth)(d);
    }, [dateToFocus, currMonth, monthsToDisplay]);
    return {
        isMobile,
        classNameId,
        currMonth,
        currYear,
        setCurrMonth,
        setCurrYear,
        renderProps,
        yearOptions,
        isDateUnavailable,
        selectedDates,
        onSelectDate,
        isDateFocusable,
        handleTodayClick,
        dateToFocus,
        onMouseEnterHighlight,
        onMouseLeaveCalendar,
        isDateInRange,
        hoveredDate,
        colorScheme,
        size,
        monthsToDisplay,
    };
};
