"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DayOfMonth = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("@chakra-ui/react");
const utils_1 = require("@chakra-ui/utils");
const date_fns_1 = require("date-fns");
const lodash_1 = require("lodash");
const CalendarContext_1 = require("./CalendarContext");
exports.DayOfMonth = (0, react_2.forwardRef)((_a, ref) => {
    var { dateObj: { date, selected, today }, isOutsideCurrMonth } = _a, props = __rest(_a, ["dateObj", "isOutsideCurrMonth"]);
    const { isDateUnavailable, isDateFocusable, onMouseEnterHighlight, isDateInRange, selectedDates, hoveredDate, size, colorScheme, } = (0, CalendarContext_1.useCalendar)();
    const isAvailable = (0, react_1.useMemo)(() => !(isDateUnavailable === null || isDateUnavailable === void 0 ? void 0 : isDateUnavailable(date)), [date, isDateUnavailable]);
    const isFocusable = (0, react_1.useMemo)(() => isDateFocusable(date), [date, isDateFocusable]);
    const isInRange = (0, react_1.useMemo)(() => isDateInRange === null || isDateInRange === void 0 ? void 0 : isDateInRange(date), [date, isDateInRange]);
    const handleMouseEnter = (0, react_1.useCallback)(() => onMouseEnterHighlight === null || onMouseEnterHighlight === void 0 ? void 0 : onMouseEnterHighlight(date), [date, onMouseEnterHighlight]);
    const styles = (0, react_2.useMultiStyleConfig)('Calendar', {
        size,
        isToday: today,
        isOutsideCurrMonth,
        colorScheme,
    });
    const isCurrentDateHovered = (0, react_1.useMemo)(() => hoveredDate && (0, date_fns_1.isSameDay)(hoveredDate, date), [date, hoveredDate]);
    const selectedBgColor = (0, react_2.useToken)('colors', `${(0, lodash_1.get)(styles, 'dayOfMonth._selected.bg')}`);
    const buttonBoxStyles = (0, react_1.useMemo)(() => {
        let gradientTo;
        // Only style background if it is a range.
        if (Array.isArray(selectedDates)) {
            const [startDate, endDate] = selectedDates;
            // Case 1: Both dates selected and equal, no need for background.
            if (startDate && endDate && (0, date_fns_1.isSameDay)(startDate, endDate)) {
                return {};
            }
            // Case 2: Hovered date with previously selected date.
            // Background corner should follow date that is hovered.
            if (hoveredDate && startDate && !endDate) {
                if ((0, date_fns_1.isSameDay)(hoveredDate, date)) {
                    gradientTo =
                        (0, date_fns_1.compareAsc)(hoveredDate, selectedDates[0]) === 1 ? 'left' : 'right';
                }
            }
            // Case 3: Current date is a selected date.
            if (startDate && (0, date_fns_1.isSameDay)(startDate, date)) {
                gradientTo = 'right';
                // Case 4: Only one date selected, background corner should follow
                // date that is selected.
                if (hoveredDate && startDate && !endDate) {
                    if ((0, date_fns_1.compareAsc)(selectedDates[0], hoveredDate) === 1) {
                        gradientTo = 'left';
                    }
                }
            }
            // Case 5: Current date is the later selected date.
            if (endDate && (0, date_fns_1.isSameDay)(endDate, date)) {
                gradientTo = 'left';
            }
            if (gradientTo) {
                return {
                    bg: `linear-gradient(to ${gradientTo}, transparent 50%,${selectedBgColor} 50%)`,
                };
            }
            // Case 6: In range but none of the above criteria. Means in between range.
            if (isInRange) {
                const returnStyles = {};
                if ((0, date_fns_1.isLastDayOfMonth)(date) || (0, date_fns_1.isSaturday)(date)) {
                    returnStyles.borderEndRadius = 'base';
                }
                if ((0, date_fns_1.isFirstDayOfMonth)(date) || (0, date_fns_1.isSunday)(date)) {
                    returnStyles.borderStartRadius = 'base';
                }
                return Object.assign({ bg: selectedBgColor }, returnStyles);
            }
        }
        // Case 7. Not in a range, no background
        return {};
    }, [date, hoveredDate, isInRange, selectedBgColor, selectedDates]);
    return ((0, jsx_runtime_1.jsx)(react_2.Flex, { sx: Object.assign(Object.assign({}, styles.dayOfMonthContainer), buttonBoxStyles), children: (0, jsx_runtime_1.jsx)(react_2.chakra.button, Object.assign({ onMouseEnter: handleMouseEnter, 
            // Prevent form submission if this component is nested in a form.
            type: "button", "data-hover": (0, utils_1.dataAttr)(isCurrentDateHovered), "data-active": (0, utils_1.dataAttr)(selected), sx: styles.dayOfMonth, "aria-label": date.toLocaleDateString(), tabIndex: isFocusable ? 0 : -1, "aria-disabled": !isAvailable, ref: ref }, props, { children: date.getDate() })) }));
});
exports.DayOfMonth.displayName = 'DayOfMonth';
