"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleSelectProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("@chakra-ui/react");
const downshift_1 = require("downshift");
const useItems_1 = require("./hooks/useItems");
const defaultFilter_1 = require("./utils/defaultFilter");
const itemUtils_1 = require("./utils/itemUtils");
const constants_1 = require("./constants");
const SelectContext_1 = require("./SelectContext");
const SingleSelectProvider = ({ items: rawItems, value, onChange, name, filter = defaultFilter_1.defaultFilter, nothingFoundLabel = 'No matching results', placeholder: placeholderProp, clearButtonLabel = 'Clear selection', isClearable = true, isSearchable = true, initialIsOpen, isInvalid: isInvalidProp, isReadOnly: isReadOnlyProp, isDisabled: isDisabledProp, isRequired: isRequiredProp, children, inputAria, colorScheme, size: _size, comboboxProps = {}, }) => {
    var _a, _b, _c, _d;
    const theme = (0, react_2.useTheme)();
    // Required in case size is set in theme, we should respect the one set in theme.
    const size = (0, react_1.useMemo)(() => {
        var _a, _b, _c, _d;
        return ((_d = _size !== null && _size !== void 0 ? _size : (_c = (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.components) === null || _a === void 0 ? void 0 : _a.SingleSelect) === null || _b === void 0 ? void 0 : _b.defaultProps) === null || _c === void 0 ? void 0 : _c.size) !== null && _d !== void 0 ? _d : 'md');
    }, [_size, (_c = (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.components) === null || _a === void 0 ? void 0 : _a.SingleSelect) === null || _b === void 0 ? void 0 : _b.defaultProps) === null || _c === void 0 ? void 0 : _c.size]);
    const { items, getItemByValue } = (0, useItems_1.useItems)({ rawItems });
    const [isFocused, setIsFocused] = (0, react_1.useState)(false);
    const { isInvalid, isDisabled, isReadOnly, isRequired } = (0, react_2.useFormControlProps)({
        isInvalid: isInvalidProp,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        isRequired: isRequiredProp,
    });
    const placeholder = (0, react_1.useMemo)(() => {
        if (placeholderProp === null)
            return '';
        return placeholderProp !== null && placeholderProp !== void 0 ? placeholderProp : 'Select an option';
    }, [placeholderProp]);
    const getFilteredItems = (0, react_1.useCallback)((filterValue) => filterValue ? filter(items, filterValue) : items, [filter, items]);
    const [filteredItems, setFilteredItems] = (0, react_1.useState)(getFilteredItems((_d = comboboxProps.initialInputValue) !== null && _d !== void 0 ? _d : comboboxProps.inputValue));
    const memoizedSelectedItem = (0, react_1.useMemo)(() => {
        var _a, _b;
        return (_b = (_a = getItemByValue(value)) === null || _a === void 0 ? void 0 : _a.item) !== null && _b !== void 0 ? _b : null;
    }, [getItemByValue, value]);
    const resetItems = (0, react_1.useCallback)(() => setFilteredItems(getFilteredItems()), [getFilteredItems]);
    const virtualListRef = (0, react_1.useRef)(null);
    const inputRef = (0, react_1.useRef)(null);
    const { toggleMenu, closeMenu, isOpen, getLabelProps, getMenuProps, getInputProps, getItemProps, getToggleButtonProps, highlightedIndex, selectItem, selectedItem, inputValue, setInputValue, } = (0, downshift_1.useCombobox)(Object.assign({ labelId: `${name}-label`, inputId: name, defaultInputValue: '', defaultHighlightedIndex: 0, items: filteredItems, initialIsOpen, selectedItem: memoizedSelectedItem, itemToString: itemUtils_1.itemToValue, onSelectedItemChange: ({ selectedItem }) => {
            if (!selectedItem || !(0, itemUtils_1.isItemDisabled)(selectedItem)) {
                onChange((0, itemUtils_1.itemToValue)(selectedItem));
            }
        }, 
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        scrollIntoView: () => { }, onHighlightedIndexChange: ({ highlightedIndex }) => {
            if (highlightedIndex !== undefined &&
                highlightedIndex >= 0 &&
                virtualListRef.current) {
                virtualListRef.current.scrollIntoView({
                    index: highlightedIndex,
                });
            }
        }, onStateChange: ({ inputValue, type }) => {
            switch (type) {
                case downshift_1.useCombobox.stateChangeTypes.FunctionSetInputValue:
                case downshift_1.useCombobox.stateChangeTypes.InputChange:
                    setFilteredItems(getFilteredItems(inputValue));
                    break;
                default:
                    return;
            }
        }, stateReducer: (state, { changes, type }) => {
            switch (type) {
                // Handle controlled `value` prop changes.
                case downshift_1.useCombobox.stateChangeTypes.ControlledPropUpdatedSelectedItem:
                    // Do nothing if selectedItem is null but yet previous state has inputValue.
                    // This suggests that there is some initial input state that we want to keep.
                    // This can only happen on first mount, since inputValue will be empty string
                    // on future actions.
                    if (state.inputValue && !changes.selectedItem) {
                        return Object.assign(Object.assign({}, changes), { inputValue: state.inputValue });
                    }
                    return Object.assign(Object.assign({}, changes), { 
                        // Clear inputValue on item selection
                        inputValue: '' });
                case downshift_1.useCombobox.stateChangeTypes.InputKeyDownEscape: {
                    if (isClearable)
                        return changes;
                    return Object.assign(Object.assign({}, changes), { selectedItem: state.selectedItem });
                }
                case downshift_1.useCombobox.stateChangeTypes.FunctionSelectItem:
                case downshift_1.useCombobox.stateChangeTypes.InputKeyDownEnter:
                case downshift_1.useCombobox.stateChangeTypes.InputBlur:
                case downshift_1.useCombobox.stateChangeTypes.ItemClick: {
                    resetItems();
                    return Object.assign(Object.assign({}, changes), { 
                        // Clear inputValue on item selection
                        inputValue: '', isOpen: false });
                }
                case downshift_1.useCombobox.stateChangeTypes.InputFocus:
                    return Object.assign(Object.assign({}, changes), { isOpen: false });
                case downshift_1.useCombobox.stateChangeTypes.ToggleButtonClick:
                    return Object.assign(Object.assign({}, changes), { isOpen: !state.isOpen });
                default:
                    return changes;
            }
        } }, comboboxProps));
    /** Effect to update filtered items whenever items prop changes. */
    (0, react_1.useEffect)(() => {
        setFilteredItems(getFilteredItems(inputValue));
    }, [getFilteredItems, inputValue, items]);
    const isItemSelected = (0, react_1.useCallback)((item) => {
        return !!selectedItem && (0, itemUtils_1.itemToValue)(selectedItem) === (0, itemUtils_1.itemToValue)(item);
    }, [selectedItem]);
    const resetInputValue = (0, react_1.useCallback)(() => setInputValue(''), [setInputValue]);
    const styles = (0, react_2.useMultiStyleConfig)('SingleSelect', {
        size,
        isClearable,
        colorScheme,
    });
    const virtualListHeight = (0, react_1.useMemo)(() => {
        const totalHeight = filteredItems.length * constants_1.VIRTUAL_LIST_ITEM_HEIGHT[size];
        // If the total height is less than the max height, just return the total height.
        // Otherwise, return the max height.
        return Math.min(totalHeight, constants_1.VIRTUAL_LIST_MAX_HEIGHT[size]);
    }, [filteredItems.length, size]);
    return ((0, jsx_runtime_1.jsx)(SelectContext_1.SelectContext.Provider, { value: {
            size,
            isOpen,
            selectedItem,
            isItemSelected,
            toggleMenu,
            closeMenu,
            getInputProps,
            getItemProps,
            getLabelProps,
            getMenuProps,
            getToggleButtonProps,
            selectItem,
            highlightedIndex,
            items: filteredItems,
            nothingFoundLabel,
            inputValue,
            isSearchable,
            isClearable,
            isInvalid,
            isDisabled,
            isReadOnly,
            isRequired,
            name,
            clearButtonLabel,
            placeholder,
            styles,
            isFocused,
            setIsFocused,
            resetInputValue,
            inputAria,
            inputRef,
            virtualListRef,
            virtualListHeight,
        }, children: children }));
};
exports.SingleSelectProvider = SingleSelectProvider;
