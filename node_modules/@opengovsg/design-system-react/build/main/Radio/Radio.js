"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OthersInput = exports.Radio = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
/**
 * This file is a slightly modified version of Chakra UI's internal Radio
 * implementation, which can be found here:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/radio/src/radio.tsx
 *
 * Limitations of Chakra's Radio mean that we cannot implement our desired
 * design with the existing implementation. In particular, the "disabled"
 * attribute does not apply to the label which wraps the component, meaning
 * we cannot apply the correct styles to the Radio container when the button
 * inside it is disabled (e.g. { cursor: 'not-allowed', bg: 'none' }).
 *
 * Hence this code is adapted to apply the desired styles to the label which
 * wraps the component.
 *
 * The relevant issue in the Chakra UI repo is here:
 * https://github.com/chakra-ui/chakra-ui/issues/4295
 */
const react_1 = require("react");
const react_2 = require("@chakra-ui/react");
const utils_1 = require("@chakra-ui/utils");
const Input_1 = require("../Input");
const RadioGroup_1 = require("./RadioGroup");
const useRadioGroupWithOthers_1 = require("./useRadioGroupWithOthers");
/**
 * Radio component is used in forms when a user needs to select a single value from
 * several options.
 *
 * @see Docs https://chakra-ui.com/radio
 */
exports.Radio = (0, react_2.forwardRef)((_a, ref) => {
    var _b;
    var { allowDeselect = true } = _a, props = __rest(_a, ["allowDeselect"]);
    const { onChange: onChangeProp, value: valueProp } = props;
    const group = (0, react_2.useRadioGroupContext)();
    const styles = (0, react_2.useMultiStyleConfig)('Radio', Object.assign(Object.assign({}, group), props));
    const ownProps = (0, react_2.omitThemingProps)(props);
    const { spacing = '0.5rem', children, isDisabled = (group === null || group === void 0 ? void 0 : group.isDisabled) || props.isDisabled, isFocusable = group === null || group === void 0 ? void 0 : group.isFocusable, inputProps: htmlInputProps } = ownProps, rest = __rest(ownProps, ["spacing", "children", "isDisabled", "isFocusable", "inputProps"]);
    let isChecked = props.isChecked;
    if ((group === null || group === void 0 ? void 0 : group.value) != null && valueProp != null) {
        isChecked = group.value === valueProp;
    }
    let onChange = onChangeProp;
    if ((group === null || group === void 0 ? void 0 : group.onChange) && valueProp != null) {
        onChange = (0, utils_1.callAll)(group.onChange, onChangeProp);
    }
    const name = (_b = props === null || props === void 0 ? void 0 : props.name) !== null && _b !== void 0 ? _b : group === null || group === void 0 ? void 0 : group.name;
    const { getInputProps, getCheckboxProps, getLabelProps, getRootProps, htmlProps, } = (0, react_2.useRadio)(Object.assign(Object.assign({}, rest), { isChecked,
        isFocusable,
        isDisabled,
        onChange,
        name }));
    const [layoutProps, otherProps] = (0, utils_1.split)(htmlProps, react_2.layoutPropNames);
    const checkboxProps = getCheckboxProps(otherProps);
    const inputProps = getInputProps(htmlInputProps, ref);
    const rootProps = Object.assign({}, layoutProps, getRootProps());
    const handleSelect = (0, react_1.useCallback)((e) => {
        if (isChecked && allowDeselect) {
            e.preventDefault();
            // Toggle off if onChange is given.
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            onChange === null || onChange === void 0 ? void 0 : onChange({ target: { value: '' } });
        }
    }, [allowDeselect, isChecked, onChange]);
    const handleSpacebar = (0, react_1.useCallback)((e) => {
        if (e.key !== ' ')
            return;
        if (isChecked && allowDeselect) {
            handleSelect(e);
        }
    }, [allowDeselect, handleSelect, isChecked]);
    // Update labelProps to include props to allow deselection of radio value if
    // available
    const labelProps = (0, react_1.useMemo)(() => {
        return getLabelProps({
            onClick: handleSelect,
            onKeyDown: handleSpacebar,
        });
    }, [getLabelProps, handleSelect, handleSpacebar]);
    const rootStyles = Object.assign(Object.assign({ display: 'inline-flex', alignItems: 'center', verticalAlign: 'top', cursor: 'pointer', position: 'relative' }, styles.container), props.__css);
    const checkboxStyles = Object.assign({ display: 'inline-flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }, styles.control);
    const labelStyles = Object.assign({ userSelect: 'none', marginStart: spacing }, styles.label);
    return ((0, jsx_runtime_1.jsxs)(react_2.chakra.label, Object.assign({ className: "chakra-radio" }, rootProps, labelProps, { __css: rootStyles, children: [(0, jsx_runtime_1.jsx)("input", Object.assign({ className: "chakra-radio__input" }, inputProps)), (0, jsx_runtime_1.jsx)(react_2.chakra.span, Object.assign({ className: "chakra-radio__control" }, checkboxProps, { __css: checkboxStyles })), children && ((0, jsx_runtime_1.jsx)(react_2.chakra.span, Object.assign({ className: "chakra-radio__label" }, labelProps, { __css: labelStyles, children: children })))] })));
});
exports.Radio.displayName = 'Radio';
/**
 * Components to support the "Others" option.
 */
const [RadioWithOthersStylesProvider, useRadioWithOthersStyles] = (0, react_2.createStylesContext)('Radio');
/**
 * Wrapper for the radio part of the Others option.
 */
const OthersRadio = (0, react_2.forwardRef)((props, ref) => {
    const { othersRadioRef, othersInputRef } = (0, useRadioGroupWithOthers_1.useRadioGroupWithOthers)();
    const { value: valueProp } = props;
    const styles = useRadioWithOthersStyles();
    const mergedRadioRef = (0, react_2.useMergeRefs)(othersRadioRef, ref);
    const group = (0, react_2.useRadioGroupContext)();
    let isChecked = props.isChecked;
    if ((group === null || group === void 0 ? void 0 : group.value) != null && valueProp != null) {
        isChecked = group.value === valueProp;
    }
    (0, react_1.useEffect)(() => {
        var _a;
        if (isChecked) {
            (_a = othersInputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }, [isChecked, othersInputRef]);
    return ((0, jsx_runtime_1.jsx)(exports.Radio, Object.assign({ ref: mergedRadioRef }, props, { __css: styles.othersRadio, children: "Other" })));
});
OthersRadio.displayName = 'OthersRadio';
/**
 * Wrapper for the input part of the Others option.
 */
exports.OthersInput = (0, react_2.forwardRef)((_a, ref) => {
    var { onChange } = _a, props = __rest(_a, ["onChange"]);
    const { othersRadioRef, othersInputRef } = (0, useRadioGroupWithOthers_1.useRadioGroupWithOthers)();
    const styles = useRadioWithOthersStyles();
    const mergedInputRef = (0, react_2.useMergeRefs)(othersInputRef, ref);
    const handleInputChange = (e) => {
        var _a, _b;
        // If user is typing text in the input, ensure the "Others" option is selected
        if (e.target.value && !((_a = othersRadioRef.current) === null || _a === void 0 ? void 0 : _a.checked)) {
            (_b = othersRadioRef.current) === null || _b === void 0 ? void 0 : _b.click();
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(e);
    };
    return ((0, jsx_runtime_1.jsx)(Input_1.Input, Object.assign({ sx: styles.othersInput, ref: mergedInputRef }, props, { onChange: handleInputChange })));
});
exports.OthersInput.displayName = 'OthersInput';
const OthersWrapper = (0, react_2.forwardRef)((_a, ref) => {
    var { children, size, colorScheme } = _a, props = __rest(_a, ["children", "size", "colorScheme"]);
    const group = (0, react_2.useRadioGroupContext)();
    const styles = (0, react_2.useMultiStyleConfig)('Radio', Object.assign({ size,
        colorScheme }, group));
    return ((0, jsx_runtime_1.jsx)(RadioWithOthersStylesProvider, { value: styles, children: (0, jsx_runtime_1.jsxs)(react_2.Box, { __css: styles.othersContainer, children: [(0, jsx_runtime_1.jsx)(OthersRadio, Object.assign({}, props, { ref: ref })), children] }) }));
});
OthersWrapper.displayName = 'OthersWrapper';
exports.Radio.OthersWrapper = OthersWrapper;
exports.Radio.RadioGroup = RadioGroup_1.RadioGroup;
exports.Radio.OthersInput = exports.OthersInput;
exports.Radio.OthersWrapper.displayName = 'Radio.OthersWrapper';
exports.Radio.RadioGroup.displayName = 'Radio.RadioGroup';
exports.Radio.OthersInput.displayName = 'Radio.OthersInput';
