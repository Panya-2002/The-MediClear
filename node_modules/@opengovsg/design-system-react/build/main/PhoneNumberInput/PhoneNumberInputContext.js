"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePhoneNumberInput = exports.PhoneNumberInputProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const libphonenumber_js_1 = require("libphonenumber-js");
const examples_1 = require("./resources/examples");
const PhoneNumberInputContext = (0, react_1.createContext)(undefined);
/**
 * Provider component that makes context object available to any
 * child component that calls `usePhoneNumberInput()`.
 */
const PhoneNumberInputProvider = (_a) => {
    var { children } = _a, contextProps = __rest(_a, ["children"]);
    const context = useProvidePhoneNumberInput(contextProps);
    return ((0, jsx_runtime_1.jsx)(PhoneNumberInputContext.Provider, { value: context, children: children }));
};
exports.PhoneNumberInputProvider = PhoneNumberInputProvider;
/**
 * Hook for components nested in PhoneNumberProvider component to get the
 * current context object.
 */
const usePhoneNumberInput = () => {
    const context = (0, react_1.useContext)(PhoneNumberInputContext);
    if (!context) {
        throw new Error(`usePhoneNumber must be used within a PhoneNumberProvider component`);
    }
    return context;
};
exports.usePhoneNumberInput = usePhoneNumberInput;
const useProvidePhoneNumberInput = (_a) => {
    var { defaultValue, defaultCountry, examplePlaceholder, examples = examples_1.MOBILE_EXAMPLES, allowInternational, onChange, onBlur } = _a, props = __rest(_a, ["defaultValue", "defaultCountry", "examplePlaceholder", "examples", "allowInternational", "onChange", "onBlur"]);
    // Internal states of the component.
    const [inputValue, setInputValue] = (0, react_1.useState)(defaultValue !== null && defaultValue !== void 0 ? defaultValue : '');
    const [country, setCountry] = (0, react_1.useState)(defaultCountry);
    // Refs of the phone number input so focus can be passed to the input when
    // the selected country changes.
    const innerInputRef = (0, react_1.useRef)(null);
    const formatter = (0, react_1.useMemo)(() => new libphonenumber_js_1.AsYouType(country), [country]);
    const inputPlaceholder = (0, react_1.useMemo)(() => {
        var _a, _b;
        if (examplePlaceholder === 'off') {
            return props.placeholder;
        }
        const exampleNumber = (_a = (0, libphonenumber_js_1.getExampleNumber)(country, examples)) === null || _a === void 0 ? void 0 : _a.formatNational();
        if (examplePlaceholder === 'aggressive') {
            return exampleNumber !== null && exampleNumber !== void 0 ? exampleNumber : props.placeholder;
        }
        return (_b = props.placeholder) !== null && _b !== void 0 ? _b : exampleNumber;
    }, [country, examplePlaceholder, examples, props.placeholder]);
    const onInputChange = (0, react_1.useCallback)((newValue) => {
        if (inputValue === newValue)
            return;
        // The as-you-type formatter only works with append-only inputs.
        // Changes other than append require a reset.
        const isAppend = newValue.length > inputValue.length &&
            newValue.slice(0, inputValue.length) === inputValue;
        if (isAppend) {
            const appended = newValue.slice(inputValue.length);
            setInputValue(formatter.input(appended));
            if (allowInternational) {
                const number = formatter.getNumber();
                if ((number === null || number === void 0 ? void 0 : number.country) && number.country !== country) {
                    setCountry(number.country);
                }
            }
        }
        else {
            // Reset the formatter, but do not reformat.
            // Doing so now will cause the user to lose their cursor position
            // Wait until blur or append to reformat.
            formatter.reset();
            formatter.input(newValue);
            setInputValue(newValue);
        }
        const number = formatter.getNumber();
        const e164 = number === null || number === void 0 ? void 0 : number.number;
        onChange(e164 !== null && e164 !== void 0 ? e164 : '');
        // On a similar vein, do not set country even if the country has changed
        // so that the cursor position does not get lost.
        // Change country on blur instead.
    }, [country, formatter, inputValue, allowInternational, onChange]);
    const handleInputChange = (0, react_1.useCallback)((e) => {
        let newValue = e.target.value;
        if (!allowInternational) {
            // Remove all non-numeric, non-space characters so country cannot be
            // changed.
            newValue = newValue.replace(/[^\d ]/g, '');
        }
        return onInputChange(newValue);
    }, [allowInternational, onInputChange]);
    const handleCountryChange = (0, react_1.useCallback)((newCountry) => {
        var _a;
        if (country === newCountry)
            return;
        onInputChange('');
        setCountry(newCountry);
        (_a = innerInputRef === null || innerInputRef === void 0 ? void 0 : innerInputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [country, onInputChange]);
    const handleFormatInput = (0, react_1.useCallback)(() => {
        var _a;
        const number = formatter.getNumber();
        // Trigger on change again in case formatted number changes.
        // This can happen in the following scenario:
        // 1. `onInputChange` gets called when user types for example "65aabvcd123"
        // 2. `formatter.getNumber().number` will transform that into "65" and cut out the remaining characters since the remaining string is not a valid number
        // 3. Will need to call onChange on this new number.
        onChange((_a = number === null || number === void 0 ? void 0 : number.number) !== null && _a !== void 0 ? _a : '');
        // Check and update possibility
        const possible = number === null || number === void 0 ? void 0 : number.isPossible();
        if (number && possible) {
            // Reformat the phone number as international if international numbers
            // are enabled.
            formatter.reset();
            const nextValue = allowInternational
                ? number.number
                : number.nationalNumber;
            setInputValue(formatter.input(nextValue));
            // Update the country if the parsed number belongs to a different
            // country.
            if (allowInternational && (number === null || number === void 0 ? void 0 : number.country) && number.country !== country) {
                setCountry(number.country);
            }
        }
        else {
            // Format the phone number
            setInputValue(formatter.input(''));
        }
    }, [country, formatter, allowInternational, onChange]);
    const handleInputBlur = (0, react_1.useCallback)(() => {
        onBlur === null || onBlur === void 0 ? void 0 : onBlur();
        handleFormatInput();
    }, [handleFormatInput, onBlur]);
    (0, react_1.useEffect)(() => {
        var _a;
        const number = (_a = formatter.getNumber()) === null || _a === void 0 ? void 0 : _a.number;
        if (number !== defaultValue) {
            // Override the phone number if the field has a number and its e164
            // representation does not match the prop value.
            formatter.reset();
            if (defaultValue) {
                formatter.input(defaultValue);
            }
            handleFormatInput();
        }
    }, [
        defaultValue,
        formatter,
        inputValue,
        onChange,
        country,
        allowInternational,
        handleFormatInput,
    ]);
    return {
        inputValue,
        country,
        innerInputRef,
        handleInputChange,
        handleInputBlur,
        handleCountryChange,
        inputPlaceholder,
    };
};
