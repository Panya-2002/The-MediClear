import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState, } from 'react';
import { AsYouType, getExampleNumber, } from 'libphonenumber-js';
import { MOBILE_EXAMPLES } from './resources/examples';
const PhoneNumberInputContext = createContext(undefined);
/**
 * Provider component that makes context object available to any
 * child component that calls `usePhoneNumberInput()`.
 */
export const PhoneNumberInputProvider = ({ children, ...contextProps }) => {
    const context = useProvidePhoneNumberInput(contextProps);
    return (_jsx(PhoneNumberInputContext.Provider, { value: context, children: children }));
};
/**
 * Hook for components nested in PhoneNumberProvider component to get the
 * current context object.
 */
export const usePhoneNumberInput = () => {
    const context = useContext(PhoneNumberInputContext);
    if (!context) {
        throw new Error(`usePhoneNumber must be used within a PhoneNumberProvider component`);
    }
    return context;
};
const useProvidePhoneNumberInput = ({ defaultValue, defaultCountry, examplePlaceholder, examples = MOBILE_EXAMPLES, allowInternational, onChange, onBlur, ...props }) => {
    // Internal states of the component.
    const [inputValue, setInputValue] = useState(defaultValue ?? '');
    const [country, setCountry] = useState(defaultCountry);
    // Refs of the phone number input so focus can be passed to the input when
    // the selected country changes.
    const innerInputRef = useRef(null);
    const formatter = useMemo(() => new AsYouType(country), [country]);
    const inputPlaceholder = useMemo(() => {
        if (examplePlaceholder === 'off') {
            return props.placeholder;
        }
        const exampleNumber = getExampleNumber(country, examples)?.formatNational();
        if (examplePlaceholder === 'aggressive') {
            return exampleNumber ?? props.placeholder;
        }
        return props.placeholder ?? exampleNumber;
    }, [country, examplePlaceholder, examples, props.placeholder]);
    const onInputChange = useCallback((newValue) => {
        if (inputValue === newValue)
            return;
        // The as-you-type formatter only works with append-only inputs.
        // Changes other than append require a reset.
        const isAppend = newValue.length > inputValue.length &&
            newValue.slice(0, inputValue.length) === inputValue;
        if (isAppend) {
            const appended = newValue.slice(inputValue.length);
            setInputValue(formatter.input(appended));
            if (allowInternational) {
                const number = formatter.getNumber();
                if (number?.country && number.country !== country) {
                    setCountry(number.country);
                }
            }
        }
        else {
            // Reset the formatter, but do not reformat.
            // Doing so now will cause the user to lose their cursor position
            // Wait until blur or append to reformat.
            formatter.reset();
            formatter.input(newValue);
            setInputValue(newValue);
        }
        const number = formatter.getNumber();
        const e164 = number?.number;
        onChange(e164 ?? '');
        // On a similar vein, do not set country even if the country has changed
        // so that the cursor position does not get lost.
        // Change country on blur instead.
    }, [country, formatter, inputValue, allowInternational, onChange]);
    const handleInputChange = useCallback((e) => {
        let newValue = e.target.value;
        if (!allowInternational) {
            // Remove all non-numeric, non-space characters so country cannot be
            // changed.
            newValue = newValue.replace(/[^\d ]/g, '');
        }
        return onInputChange(newValue);
    }, [allowInternational, onInputChange]);
    const handleCountryChange = useCallback((newCountry) => {
        if (country === newCountry)
            return;
        onInputChange('');
        setCountry(newCountry);
        innerInputRef?.current?.focus();
    }, [country, onInputChange]);
    const handleFormatInput = useCallback(() => {
        const number = formatter.getNumber();
        // Trigger on change again in case formatted number changes.
        // This can happen in the following scenario:
        // 1. `onInputChange` gets called when user types for example "65aabvcd123"
        // 2. `formatter.getNumber().number` will transform that into "65" and cut out the remaining characters since the remaining string is not a valid number
        // 3. Will need to call onChange on this new number.
        onChange(number?.number ?? '');
        // Check and update possibility
        const possible = number?.isPossible();
        if (number && possible) {
            // Reformat the phone number as international if international numbers
            // are enabled.
            formatter.reset();
            const nextValue = allowInternational
                ? number.number
                : number.nationalNumber;
            setInputValue(formatter.input(nextValue));
            // Update the country if the parsed number belongs to a different
            // country.
            if (allowInternational && number?.country && number.country !== country) {
                setCountry(number.country);
            }
        }
        else {
            // Format the phone number
            setInputValue(formatter.input(''));
        }
    }, [country, formatter, allowInternational, onChange]);
    const handleInputBlur = useCallback(() => {
        onBlur?.();
        handleFormatInput();
    }, [handleFormatInput, onBlur]);
    useEffect(() => {
        const number = formatter.getNumber()?.number;
        if (number !== defaultValue) {
            // Override the phone number if the field has a number and its e164
            // representation does not match the prop value.
            formatter.reset();
            if (defaultValue) {
                formatter.input(defaultValue);
            }
            handleFormatInput();
        }
    }, [
        defaultValue,
        formatter,
        inputValue,
        onChange,
        country,
        allowInternational,
        handleFormatInput,
    ]);
    return {
        inputValue,
        country,
        innerInputRef,
        handleInputChange,
        handleInputBlur,
        handleCountryChange,
        inputPlaceholder,
    };
};
