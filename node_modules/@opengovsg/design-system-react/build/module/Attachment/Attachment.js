import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useMemo } from 'react';
import { useDropzone } from 'react-dropzone';
import { Box, forwardRef, Text, useFormControl, useMergeRefs, useMultiStyleConfig, } from '@chakra-ui/react';
import { dataAttr } from '@chakra-ui/utils';
import { omit } from 'lodash';
import { AttachmentStylesProvider } from './AttachmentContext';
import { AttachmentDropzone } from './AttachmentDropzone';
import { AttachmentFileInfo } from './AttachmentFileInfo';
import { getFileExtension, getReadableFileSize } from './utils';
export const Attachment = forwardRef(({ onChange, onError, maxSize, showFileSize, accept, value, name, colorScheme, imagePreview, onFileValidation, ...props }, ref) => {
    // Merge given props with any form control props, if they exist.
    const inputProps = useFormControl(props);
    // id to set on the rendered max size FormHelperText component.
    const maxSizeTextId = useMemo(() => `${name}-max-size`, [name]);
    const readableMaxSize = useMemo(() => (maxSize ? getReadableFileSize(maxSize) : undefined), [maxSize]);
    const showMaxSize = useMemo(() => !value && showFileSize && readableMaxSize, [value, readableMaxSize, showFileSize]);
    const ariaDescribedBy = useMemo(() => {
        const describedByIds = new Set();
        // Must be in this order so the screen reader reads out something coherent.
        // 1. Label text (if available)
        // 2. Initial describedby text (if available)
        // 3. Max size text (if prop is true)
        if (inputProps.id) {
            describedByIds.add(`${inputProps.id}-label`);
        }
        inputProps['aria-describedby']
            ?.split(' ')
            .map((id) => describedByIds.add(id));
        if (showMaxSize) {
            describedByIds.add(maxSizeTextId);
        }
        // Remove helptext, since label should already consist of the text
        describedByIds.delete(`${inputProps.id}-helptext`);
        return Array.from(describedByIds).filter(Boolean).join(' ').trim();
    }, [inputProps, maxSizeTextId, showMaxSize]);
    const handleFileDrop = useCallback(async ([acceptedFile], rejectedFiles) => {
        if (rejectedFiles.length > 0) {
            const firstError = rejectedFiles[0].errors[0];
            let errorMessage;
            switch (firstError.code) {
                case 'file-invalid-type': {
                    const fileExt = getFileExtension(rejectedFiles[0].file.name);
                    errorMessage = `Your file's extension ending in *${fileExt} is not allowed`;
                    break;
                }
                case 'too-many-files': {
                    errorMessage = 'You can only upload a single file in this input';
                    break;
                }
                default:
                    errorMessage = firstError.message;
            }
            return onError?.(errorMessage);
        }
        const fileValidationErrorMessage = await onFileValidation?.(acceptedFile);
        if (fileValidationErrorMessage) {
            return onError?.(fileValidationErrorMessage);
        }
        onChange(acceptedFile);
    }, [onChange, onError, onFileValidation]);
    const fileValidator = useCallback((file) => {
        if (maxSize && file.size > maxSize) {
            return {
                code: 'file-too-large',
                message: `You have exceeded the limit, please upload a file below ${readableMaxSize}`,
            };
        }
        return null;
    }, [maxSize, readableMaxSize]);
    const { getRootProps, getInputProps, isDragActive, rootRef } = useDropzone({
        multiple: false,
        accept,
        disabled: inputProps.disabled,
        validator: fileValidator,
        noClick: inputProps.readOnly,
        noDrag: inputProps.readOnly,
        onDrop: handleFileDrop,
    });
    const mergedRefs = useMergeRefs(rootRef, ref);
    const styles = useMultiStyleConfig('Attachment', {
        isDragActive,
        colorScheme,
        imagePreview,
    });
    const handleRemoveFile = useCallback(() => {
        onChange(undefined);
        rootRef.current?.focus();
    }, [onChange, rootRef]);
    // Bunch of memoization to avoid unnecessary re-renders.
    const processedRootProps = useMemo(() => {
        return getRootProps({
            // Root div does not need id prop, prevents duplicate ids.
            ...omit(inputProps, 'id'),
            // Bunch of extra work to prevent field from being used when in readOnly
            // state.
            onKeyDown: (e) => {
                if (inputProps.readOnly) {
                    e.stopPropagation();
                    return;
                }
            },
            'aria-describedby': ariaDescribedBy,
        });
    }, [ariaDescribedBy, getRootProps, inputProps]);
    const processedInputProps = useMemo(() => {
        return getInputProps({
            name,
            ...inputProps,
        });
    }, [getInputProps, inputProps, name]);
    return (_jsx(AttachmentStylesProvider, { value: styles, children: _jsxs(Box, { __css: styles.container, children: [_jsx(Box, { ...processedRootProps, ref: mergedRefs, "data-active": dataAttr(isDragActive), __css: value ? undefined : styles.dropzone, children: value ? (_jsx(AttachmentFileInfo, { file: value, imagePreview: imagePreview, handleRemoveFile: handleRemoveFile, isDisabled: inputProps.disabled, isReadOnly: inputProps.readOnly })) : (_jsx(AttachmentDropzone, { isDragActive: isDragActive, inputProps: processedInputProps })) }), showMaxSize ? (_jsxs(Text, { id: maxSizeTextId, color: "base.content.medium", mt: "0.5rem", textStyle: "body-2", children: ["Maximum file size: ", readableMaxSize] })) : null] }) }));
});
Attachment.displayName = 'Attachment';
