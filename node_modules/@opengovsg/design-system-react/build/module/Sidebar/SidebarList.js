import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useMemo } from 'react';
import { Box, chakra, Collapse, forwardRef, Icon, useDisclosure, } from '@chakra-ui/react';
import { dataAttr, isFunction } from '@chakra-ui/utils';
import { merge } from 'lodash';
import { ToggleChevron } from '../icons';
import { SidebarNestProvider, useSidebarContext, useSidebarStyles, } from './SidebarContext';
const SidebarSection = ({ children, isOpen, }) => {
    const { reduceMotion } = useSidebarContext();
    const styles = useSidebarStyles();
    const child = _jsx(chakra.ul, { __css: styles.nest, children: children });
    if (reduceMotion)
        return child;
    return _jsx(Collapse, { in: isOpen, children: child });
};
export const SidebarList = forwardRef(({ label, children, icon, iconProps, isActive, defaultIsExpanded, isExpanded: isExpandedProp, onExpand: onExpandProp, onlyCaretToggle = false, onClick, ...props }, ref) => {
    const styles = useSidebarStyles();
    const { reduceMotion } = useSidebarContext();
    const { isOpen, onToggle } = useDisclosure({
        defaultIsOpen: defaultIsExpanded,
        isOpen: isExpandedProp,
        onClose: () => onExpandProp?.(false),
        onOpen: () => onExpandProp?.(true),
    });
    const handleExpandSection = useCallback(() => {
        if (!onlyCaretToggle) {
            onToggle();
        }
        onClick?.();
    }, [onClick, onToggle, onlyCaretToggle]);
    const dataActive = useMemo(() => {
        if (isFunction(isActive)) {
            return isActive();
        }
        return isActive;
    }, [isActive]);
    const itemCss = useMemo(() => {
        const mergedStyles = merge({}, styles.item, styles.parent);
        if (onlyCaretToggle)
            return mergedStyles;
        return merge({}, mergedStyles, { cursor: 'pointer' });
    }, [onlyCaretToggle, styles.item, styles.parent]);
    const SectionWrapper = useMemo(() => {
        if (onlyCaretToggle)
            return chakra.div;
        return chakra.button;
    }, [onlyCaretToggle]);
    const ToggleChevronWrapper = useMemo(() => {
        if (onlyCaretToggle)
            return chakra.button;
        return chakra.div;
    }, [onlyCaretToggle]);
    return (_jsx(chakra.li, { __css: styles.list, pl: 0, ref: ref, ...props, children: _jsxs(Box, { children: [_jsxs(SectionWrapper, { __css: itemCss, "data-expanded": dataAttr(isOpen), "data-active": dataAttr(dataActive), onClick: handleExpandSection, children: [_jsxs(chakra.span, { flex: 1, __css: styles.label, children: [icon ? (_jsx(Icon, { as: icon, __css: styles.icon, ...iconProps })) : null, label] }), _jsx(ToggleChevronWrapper, { layerStyle: "focusRing.default", "aria-label": onlyCaretToggle ? 'Toggle section' : undefined, onClick: onToggle, display: "flex", outline: "none", children: _jsx(ToggleChevron, { reduceMotion: reduceMotion, isOpen: isOpen, styles: styles.icon }) })] }), _jsx(SidebarNestProvider, { nested: true, children: _jsx(SidebarSection, { isOpen: isOpen, children: children }) })] }) }));
});
SidebarList.displayName = 'SidebarList';
