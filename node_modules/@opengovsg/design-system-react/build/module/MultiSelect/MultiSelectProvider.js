import { jsx as _jsx } from "react/jsx-runtime";
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useFormControlProps, useMultiStyleConfig, useTheme, } from '@chakra-ui/react';
import { useCombobox, useMultipleSelection, } from 'downshift';
import { SelectContext, } from '../SingleSelect';
import { VIRTUAL_LIST_ITEM_HEIGHT, VIRTUAL_LIST_MAX_HEIGHT, } from '../SingleSelect/constants';
import { useItems } from '../SingleSelect/hooks/useItems';
import { defaultFilter, isItemDisabled, itemToLabelString, itemToValue, } from '../SingleSelect/utils';
import { MultiSelectContext } from './MultiSelectContext';
export const MultiSelectProvider = ({ items: rawItems, values, onChange, name, filter = defaultFilter, nothingFoundLabel = 'No matching results', placeholder: placeholderProp, clearButtonLabel = 'Clear selection', isSearchable = true, defaultIsOpen, isInvalid: isInvalidProp, isReadOnly: isReadOnlyProp, isDisabled: isDisabledProp, isRequired: isRequiredProp, maxItems = 4, downshiftComboboxProps = {}, downshiftMultiSelectProps = {}, inputAria, children, size: _size, colorScheme, }) => {
    const theme = useTheme();
    // Required in case size is set in theme, we should respect the one set in theme.
    const size = useMemo(() => (_size ?? theme?.components?.MultiSelect?.defaultProps?.size ?? 'md'), [_size, theme?.components?.MultiSelect?.defaultProps?.size]);
    const { items, getItemByValue } = useItems({ rawItems });
    const [isFocused, setIsFocused] = useState(false);
    // Inject for components to manipulate
    const inputRef = useRef(null);
    const virtualListRef = useRef(null);
    const { isInvalid, isDisabled, isReadOnly, isRequired } = useFormControlProps({
        isInvalid: isInvalidProp,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        isRequired: isRequiredProp,
    });
    const getFilteredItems = useCallback((filterValue) => {
        return filterValue ? filter(items, filterValue) : items;
    }, [filter, items]);
    const [filteredItems, setFilteredItems] = useState(getFilteredItems(downshiftComboboxProps.initialInputValue ??
        downshiftComboboxProps.inputValue));
    const selectedItems = useMemo(() => {
        const items = [];
        for (const value of values) {
            const item = getItemByValue(value);
            if (item) {
                items.push(item.item);
            }
        }
        return items;
    }, [getItemByValue, values]);
    const { getSelectedItemProps, getDropdownProps, addSelectedItem, removeSelectedItem, reset, activeIndex, setActiveIndex, } = useMultipleSelection({
        selectedItems,
        onSelectedItemsChange: ({ selectedItems }) => {
            onChange(selectedItems
                ?.filter((item) => !isItemDisabled(item))
                .map(itemToValue) ?? []);
        },
        itemToString: itemToLabelString,
        stateReducer: (_state, { changes, type }) => {
            switch (type) {
                case useMultipleSelection.stateChangeTypes.FunctionRemoveSelectedItem:
                    return {
                        ...changes,
                        // The focus will move to the input/button
                        // This prevents a bug where the focus would move to a selected item
                        // when deselecting a selected item in the dropdown.
                        activeIndex: -1,
                    };
                default:
                    return changes;
            }
        },
        ...downshiftMultiSelectProps,
    });
    const dynamicPlaceholder = useMemo(() => {
        if (placeholderProp === null || selectedItems.length > 0)
            return '';
        return placeholderProp ?? 'Select options';
    }, [placeholderProp, selectedItems.length]);
    const { toggleMenu, closeMenu, isOpen, getLabelProps, getMenuProps, getInputProps, getItemProps, getToggleButtonProps, selectItem, inputValue, highlightedIndex, setInputValue, } = useCombobox({
        labelId: `${name}-label`,
        inputId: name,
        items: filteredItems,
        itemToString: itemToLabelString,
        defaultIsOpen,
        defaultInputValue: '',
        defaultHighlightedIndex: 0,
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        scrollIntoView: () => { },
        onHighlightedIndexChange: ({ highlightedIndex }) => {
            if (highlightedIndex !== undefined &&
                highlightedIndex >= 0 &&
                virtualListRef.current) {
                virtualListRef.current.scrollIntoView({
                    index: highlightedIndex,
                });
            }
        },
        onStateChange: ({ inputValue, type }) => {
            switch (type) {
                case useCombobox.stateChangeTypes.FunctionSetInputValue:
                case useCombobox.stateChangeTypes.InputChange:
                    setFilteredItems(getFilteredItems(inputValue));
                    break;
                default:
                    return;
            }
        },
        stateReducer: (state, { changes, type }) => {
            switch (type) {
                case useCombobox.stateChangeTypes.InputKeyDownEnter:
                case useCombobox.stateChangeTypes.ItemClick: {
                    const { selectedItem } = changes;
                    if (selectedItem) {
                        if (selectedItems.includes(selectedItem)) {
                            removeSelectedItem(selectedItem);
                        }
                        else {
                            addSelectedItem(selectedItem);
                        }
                    }
                    return {
                        ...changes,
                        // Retain previous inputValue
                        inputValue: state.inputValue,
                        // Keep highlighted index the same.
                        highlightedIndex: state.highlightedIndex,
                        selectedItem: null,
                        // Keep the menu open after selection.
                        isOpen: true,
                    };
                }
                case useCombobox.stateChangeTypes.InputBlur:
                    setFilteredItems(getFilteredItems());
                    // Clear input regardless on blur.
                    return {
                        ...changes,
                        inputValue: '',
                        isOpen: false,
                    };
                case useCombobox.stateChangeTypes.InputFocus:
                    return {
                        ...changes,
                        isOpen: false, // keep the menu closed when input gets focused.
                    };
                case useCombobox.stateChangeTypes.ToggleButtonClick:
                    return {
                        ...changes,
                        isOpen: !state.isOpen,
                    };
                default:
                    return changes;
            }
        },
        ...downshiftComboboxProps,
    });
    /** Effect to update filtered items whenever items prop changes. */
    useEffect(() => {
        setFilteredItems(getFilteredItems(inputValue));
    }, [getFilteredItems, inputValue, items]);
    const resetInputValue = useCallback(() => setInputValue(''), [setInputValue]);
    const isItemSelected = useCallback((item) => {
        return selectedItems.includes(item);
    }, [selectedItems]);
    const styles = useMultiStyleConfig('MultiSelect', {
        size,
        isFocused: isFocused || isOpen,
        isEmpty: selectedItems.length === 0,
    });
    const virtualListHeight = useMemo(() => {
        const totalHeight = filteredItems.length * VIRTUAL_LIST_ITEM_HEIGHT[size];
        // If the total height is less than the max height, just return the total height.
        // Otherwise, return the max height.
        return Math.min(totalHeight, VIRTUAL_LIST_MAX_HEIGHT[size]);
    }, [filteredItems.length, size]);
    return (_jsx(SelectContext.Provider, { value: {
            size,
            inputRef,
            isClearable: false,
            selectedItem: null,
            isOpen,
            isItemSelected,
            toggleMenu,
            closeMenu,
            getInputProps,
            getItemProps,
            getLabelProps,
            getMenuProps,
            getToggleButtonProps,
            selectItem,
            highlightedIndex,
            items: filteredItems,
            nothingFoundLabel,
            inputValue,
            isSearchable,
            name,
            clearButtonLabel,
            placeholder: dynamicPlaceholder,
            styles,
            isFocused,
            setIsFocused,
            isInvalid,
            isDisabled,
            isReadOnly,
            isRequired,
            resetInputValue,
            inputAria,
            virtualListRef,
            virtualListHeight,
        }, children: _jsx(MultiSelectContext.Provider, { value: {
                selectedItems,
                getDropdownProps,
                getSelectedItemProps,
                addSelectedItem,
                removeSelectedItem,
                reset,
                maxItems,
                activeIndex,
                setActiveIndex,
                colorScheme,
            }, children: children }) }));
};
