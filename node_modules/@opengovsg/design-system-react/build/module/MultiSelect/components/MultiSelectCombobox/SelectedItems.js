import { jsxs as _jsxs, jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import { useCallback, useMemo } from 'react';
import { Button } from '../../../Button';
import { useSelectContext } from '../../../SingleSelect';
import { useMultiSelectContext } from '../../MultiSelectContext';
import { MultiSelectItem } from '../MultiSelectItem';
const ShowMoreItemBlock = ({ amountToShow }) => {
    const { isDisabled, isReadOnly, setIsFocused, inputRef } = useSelectContext();
    const handleClick = useCallback((e) => {
        // Prevent click from bubbling to parent.
        e.stopPropagation();
        if (isDisabled || isReadOnly)
            return;
        setIsFocused(true);
        inputRef?.current?.focus();
    }, [inputRef, isDisabled, isReadOnly, setIsFocused]);
    return (_jsxs(Button, { onClick: handleClick, variant: "link", size: "sm", tabIndex: -1, alignSelf: "center", children: ["+", amountToShow, " more"] }));
};
export const SelectedItems = () => {
    const { selectedItems, maxItems } = useMultiSelectContext();
    const { isFocused, isOpen } = useSelectContext();
    const items = useMemo(() => {
        const itemsToRender = [];
        for (let i = 0; i < selectedItems.length; i++) {
            if (isFocused || !maxItems || i < maxItems || isOpen) {
                const item = selectedItems[i];
                // Key has to be index so focus is maintained correctly when items are removed.
                // Some downshift quirk it seems.
                itemsToRender.push(_jsx(MultiSelectItem, { item: item, index: i }, i));
            }
            else {
                itemsToRender.push(_jsx(ShowMoreItemBlock, { amountToShow: selectedItems.length - maxItems }, `show-more-${i}`));
                break;
            }
        }
        return itemsToRender;
    }, [isFocused, isOpen, maxItems, selectedItems]);
    return _jsx(_Fragment, { children: items });
};
