import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * This file is a slightly modified version of Chakra UI's internal Radio
 * implementation, which can be found here:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/radio/src/radio.tsx
 *
 * Limitations of Chakra's Radio mean that we cannot implement our desired
 * design with the existing implementation. In particular, the "disabled"
 * attribute does not apply to the label which wraps the component, meaning
 * we cannot apply the correct styles to the Radio container when the button
 * inside it is disabled (e.g. { cursor: 'not-allowed', bg: 'none' }).
 *
 * Hence this code is adapted to apply the desired styles to the label which
 * wraps the component.
 *
 * The relevant issue in the Chakra UI repo is here:
 * https://github.com/chakra-ui/chakra-ui/issues/4295
 */
import { useCallback, useEffect, useMemo, } from 'react';
import { Box, chakra, createStylesContext, forwardRef, layoutPropNames, omitThemingProps, useMergeRefs, useMultiStyleConfig, useRadio, useRadioGroupContext, } from '@chakra-ui/react';
import { callAll, split } from '@chakra-ui/utils';
import { Input } from '../Input';
import { RadioGroup } from './RadioGroup';
import { useRadioGroupWithOthers } from './useRadioGroupWithOthers';
/**
 * Radio component is used in forms when a user needs to select a single value from
 * several options.
 *
 * @see Docs https://chakra-ui.com/radio
 */
export const Radio = forwardRef(({ allowDeselect = true, ...props }, ref) => {
    const { onChange: onChangeProp, value: valueProp } = props;
    const group = useRadioGroupContext();
    const styles = useMultiStyleConfig('Radio', { ...group, ...props });
    const ownProps = omitThemingProps(props);
    const { spacing = '0.5rem', children, isDisabled = group?.isDisabled || props.isDisabled, isFocusable = group?.isFocusable, inputProps: htmlInputProps, ...rest } = ownProps;
    let isChecked = props.isChecked;
    if (group?.value != null && valueProp != null) {
        isChecked = group.value === valueProp;
    }
    let onChange = onChangeProp;
    if (group?.onChange && valueProp != null) {
        onChange = callAll(group.onChange, onChangeProp);
    }
    const name = props?.name ?? group?.name;
    const { getInputProps, getCheckboxProps, getLabelProps, getRootProps, htmlProps, } = useRadio({
        ...rest,
        isChecked,
        isFocusable,
        isDisabled,
        onChange,
        name,
    });
    const [layoutProps, otherProps] = split(htmlProps, layoutPropNames);
    const checkboxProps = getCheckboxProps(otherProps);
    const inputProps = getInputProps(htmlInputProps, ref);
    const rootProps = Object.assign({}, layoutProps, getRootProps());
    const handleSelect = useCallback((e) => {
        if (isChecked && allowDeselect) {
            e.preventDefault();
            // Toggle off if onChange is given.
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            onChange?.({ target: { value: '' } });
        }
    }, [allowDeselect, isChecked, onChange]);
    const handleSpacebar = useCallback((e) => {
        if (e.key !== ' ')
            return;
        if (isChecked && allowDeselect) {
            handleSelect(e);
        }
    }, [allowDeselect, handleSelect, isChecked]);
    // Update labelProps to include props to allow deselection of radio value if
    // available
    const labelProps = useMemo(() => {
        return getLabelProps({
            onClick: handleSelect,
            onKeyDown: handleSpacebar,
        });
    }, [getLabelProps, handleSelect, handleSpacebar]);
    const rootStyles = {
        display: 'inline-flex',
        alignItems: 'center',
        verticalAlign: 'top',
        cursor: 'pointer',
        position: 'relative',
        ...styles.container,
        ...props.__css,
    };
    const checkboxStyles = {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        flexShrink: 0,
        ...styles.control,
    };
    const labelStyles = {
        userSelect: 'none',
        marginStart: spacing,
        ...styles.label,
    };
    return (_jsxs(chakra.label, { className: "chakra-radio", ...rootProps, ...labelProps, __css: rootStyles, children: [_jsx("input", { className: "chakra-radio__input", ...inputProps }), _jsx(chakra.span, { className: "chakra-radio__control", ...checkboxProps, __css: checkboxStyles }), children && (_jsx(chakra.span, { className: "chakra-radio__label", ...labelProps, __css: labelStyles, children: children }))] }));
});
Radio.displayName = 'Radio';
/**
 * Components to support the "Others" option.
 */
const [RadioWithOthersStylesProvider, useRadioWithOthersStyles] = createStylesContext('Radio');
/**
 * Wrapper for the radio part of the Others option.
 */
const OthersRadio = forwardRef((props, ref) => {
    const { othersRadioRef, othersInputRef } = useRadioGroupWithOthers();
    const { value: valueProp } = props;
    const styles = useRadioWithOthersStyles();
    const mergedRadioRef = useMergeRefs(othersRadioRef, ref);
    const group = useRadioGroupContext();
    let isChecked = props.isChecked;
    if (group?.value != null && valueProp != null) {
        isChecked = group.value === valueProp;
    }
    useEffect(() => {
        if (isChecked) {
            othersInputRef.current?.focus();
        }
    }, [isChecked, othersInputRef]);
    return (_jsx(Radio, { ref: mergedRadioRef, ...props, __css: styles.othersRadio, children: "Other" }));
});
OthersRadio.displayName = 'OthersRadio';
/**
 * Wrapper for the input part of the Others option.
 */
export const OthersInput = forwardRef(({ onChange, ...props }, ref) => {
    const { othersRadioRef, othersInputRef } = useRadioGroupWithOthers();
    const styles = useRadioWithOthersStyles();
    const mergedInputRef = useMergeRefs(othersInputRef, ref);
    const handleInputChange = (e) => {
        // If user is typing text in the input, ensure the "Others" option is selected
        if (e.target.value && !othersRadioRef.current?.checked) {
            othersRadioRef.current?.click();
        }
        onChange?.(e);
    };
    return (_jsx(Input, { sx: styles.othersInput, ref: mergedInputRef, ...props, onChange: handleInputChange }));
});
OthersInput.displayName = 'OthersInput';
const OthersWrapper = forwardRef(({ children, size, colorScheme, ...props }, ref) => {
    const group = useRadioGroupContext();
    const styles = useMultiStyleConfig('Radio', {
        size,
        colorScheme,
        ...group,
    });
    return (_jsx(RadioWithOthersStylesProvider, { value: styles, children: _jsxs(Box, { __css: styles.othersContainer, children: [_jsx(OthersRadio, { ...props, ref: ref }), children] }) }));
});
OthersWrapper.displayName = 'OthersWrapper';
Radio.OthersWrapper = OthersWrapper;
Radio.RadioGroup = RadioGroup;
Radio.OthersInput = OthersInput;
Radio.OthersWrapper.displayName = 'Radio.OthersWrapper';
Radio.RadioGroup.displayName = 'Radio.RadioGroup';
Radio.OthersInput.displayName = 'Radio.OthersInput';
