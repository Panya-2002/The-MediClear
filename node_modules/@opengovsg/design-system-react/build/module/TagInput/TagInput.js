import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useRef, } from 'react';
import { RovingTabIndexProvider } from 'react-roving-tabindex';
import { Box, forwardRef, useControllableState, useFormControl, useMergeRefs, useMultiStyleConfig, } from '@chakra-ui/react';
import { TagInputInput } from './TagInputInput';
import { TagInputProvider } from './TagInputProvider';
import { TagInputTag } from './TagInputTag';
export const TagInput = forwardRef(({ value: valueProp, defaultValue = [], onChange: onChangeProp, onKeyDown, onBlur, keyDownKeys = ['Enter', ',', ' '], tagColorScheme = 'main', tagValidation = () => true, preventDuplicates = true, size, ...props }, ref) => {
    const inputProps = useFormControl(props);
    const styles = useMultiStyleConfig('TagInput', { ...inputProps, size });
    const [value, onChange] = useControllableState({
        value: valueProp,
        onChange: onChangeProp,
        defaultValue,
    });
    const inputRef = useRef(null);
    const mergedInputRefs = useMergeRefs(ref, inputRef);
    const handleFieldClick = useCallback(() => {
        inputRef.current?.focus();
    }, []);
    const addTag = useCallback((event, tag) => {
        if (event.isDefaultPrevented())
            return;
        if (preventDuplicates) {
            if (value.includes(tag))
                return;
            onChange(Array.from(new Set([...value, ...tag.split(',')])));
        }
        else {
            onChange(value.concat(tag.split(',')));
        }
    }, [onChange, preventDuplicates, value]);
    const removeTag = useCallback((event, index) => {
        if (event.isDefaultPrevented())
            return;
        onChange([...value.slice(0, index), ...value.slice(index + 1)]);
    }, [onChange, value]);
    const handleRemoveTag = useCallback((index) => (event) => {
        removeTag(event, index);
    }, [removeTag]);
    const handleBlur = useCallback((event) => {
        const currentValue = event.target.value;
        // No value to add a tag to.
        if (!currentValue.trim()) {
            event.target.value = '';
        }
        else {
            addTag(event, currentValue);
            if (!event.isDefaultPrevented()) {
                event.target.value = '';
            }
            event.preventDefault();
        }
        onBlur?.(event);
    }, [addTag, onBlur]);
    const handleKeyDown = useCallback((event) => {
        onKeyDown?.(event);
        if (event.isDefaultPrevented())
            return;
        if (event.isPropagationStopped())
            return;
        const { currentTarget, key } = event;
        const { selectionStart, selectionEnd } = currentTarget;
        if (key === 'Backspace' &&
            value.length > 0 &&
            selectionStart === 0 &&
            selectionEnd === 0) {
            return removeTag(event, value.length - 1);
        }
        if (!currentTarget.value.trim())
            return; // No value to add a tag to.
        if (keyDownKeys.indexOf(key) > -1 && currentTarget.value) {
            addTag(event, currentTarget.value);
            if (!event.isDefaultPrevented()) {
                currentTarget.value = '';
            }
            event.preventDefault();
        }
    }, [onKeyDown, keyDownKeys, value.length, addTag, removeTag]);
    return (_jsx(RovingTabIndexProvider, { children: _jsx(TagInputProvider, { styles: styles, children: _jsxs(Box, { sx: styles.container, onClick: handleFieldClick, "aria-disabled": inputProps.disabled, "aria-invalid": inputProps['aria-invalid'], "aria-readonly": inputProps.readOnly, children: [value.map((tag, index) => (_jsx(TagInputTag, { isDisabled: inputProps.disabled, colorScheme: tagColorScheme, isInvalid: !tagValidation(tag), label: tag, onClearTag: handleRemoveTag(index), onBlur: onBlur, size: size }, index))), _jsx(TagInputInput, { ...inputProps, onKeyDown: handleKeyDown, onBlur: handleBlur, ref: mergedInputRefs })] }) }) }));
});
