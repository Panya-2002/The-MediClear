import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useMemo, useState, } from 'react';
import { addMonths, differenceInCalendarMonths, isFirstDayOfMonth, isSameDay, } from 'date-fns';
import { useDayzed } from 'dayzed';
import { inRange } from 'lodash';
import { customAlphabet } from 'nanoid/non-secure';
import { useKey } from 'rooks';
import { useIsMobile } from '../../hooks';
import { generateClassNameForDate, getDateFromClassName, getMonthOffsetFromToday, getNewDateFromKeyPress, getYearOptions, } from './utils';
const ARROW_KEY_NAMES = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
// Removed - and _ from alphabets for simpler classnames
const nanoid = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 16);
const CalendarContext = createContext(undefined);
export const CalendarProvider = ({ children, ...props }) => {
    const value = useProvideCalendar(props);
    return (_jsx(CalendarContext.Provider, { value: value, children: children }));
};
export const useCalendar = () => {
    const context = useContext(CalendarContext);
    if (!context) {
        throw new Error('useCalendar must be used within a CalendarProvider');
    }
    return context;
};
const useProvideCalendar = ({ selectedDates, onSelectDate, isDateUnavailable, monthsToDisplay = 1, onMouseEnterHighlight, onMouseLeaveCalendar, isDateInRange, hoveredDate, colorScheme, size, ssr, defaultFocusedDate, }) => {
    const isMobile = useIsMobile({ ssr });
    // Ensure that calculations are always made based on date of initial render,
    // so component state doesn't suddenly jump at midnight
    const today = useMemo(() => new Date(), []);
    // Unique className for dates
    const classNameId = useMemo(() => nanoid(), []);
    const yearOptions = useMemo(() => getYearOptions(), []);
    // Date to focus on initial render if initialFocusRef is passed
    const dateToFocus = useMemo(() => {
        if (Array.isArray(selectedDates) && selectedDates[0]) {
            return selectedDates[0];
        }
        if (selectedDates instanceof Date) {
            return selectedDates;
        }
        return defaultFocusedDate ?? today;
    }, [today, selectedDates, defaultFocusedDate]);
    const [currMonth, setCurrMonth] = useState(dateToFocus.getMonth());
    const [currYear, setCurrYear] = useState(dateToFocus.getFullYear());
    /**
     * Updates the current year and month when the forward/back arrows are clicked.
     * We need to pass this to Dayzed because we want to control the current year
     * and month via both the dropdowns and arrows.
     */
    const onOffsetChanged = useCallback((offset) => {
        const newDate = addMonths(today, offset);
        setCurrYear(newDate.getFullYear());
        setCurrMonth(newDate.getMonth());
    }, [today]);
    /**
     * Handles user clicking on "Today" at bottom of datepicker
     */
    const handleTodayClick = useCallback(() => {
        // Get most updated "today", rather than "today" at the point
        // of component rendering
        const today = new Date();
        setCurrMonth(today.getMonth());
        setCurrYear(today.getFullYear());
        // Workaround to ensure that the correct element is in the DOM
        // before running document.querySelector
        setTimeout(() => {
            const elementToFocus = document.querySelector(`.${generateClassNameForDate(classNameId, today)}`);
            elementToFocus?.focus();
        });
    }, [classNameId]);
    const updateMonthYear = useCallback((newDate) => {
        const monthDiff = differenceInCalendarMonths(newDate, new Date(currYear, currMonth));
        if (monthDiff < 0 || monthDiff > monthsToDisplay - 1) {
            setCurrMonth(newDate.getMonth());
            setCurrYear(newDate.getFullYear());
        }
    }, [currMonth, currYear, monthsToDisplay]);
    /**
     * Allows user to change focus across rows/columns using arrow keys. The
     * idea is to attach a unique classname to each day, from which we can derive
     * the date which it corresponds to.
     * This function implements an effect where using the arrow key to move
     * to dates outside the current month (i.e. the greyed-out dates from the previous
     * and next months) will cause the datepicker to scroll to that month. However,
     * note that we DO NOT want this effect to happen for tabs too, as this would mean
     * the user can never tab outside the datepicker.
     */
    const handleArrowKey = useCallback((e) => {
        const currentlyFocused = document.activeElement;
        if (!currentlyFocused ||
            !currentlyFocused.className.includes(classNameId)) {
            return;
        }
        const focusedDate = getDateFromClassName(currentlyFocused.className, classNameId);
        if (!focusedDate)
            return;
        // Prevent arrow key from scrolling screen
        e.preventDefault();
        const newDate = getNewDateFromKeyPress(focusedDate, e.key);
        if (newDate === focusedDate)
            return;
        // If newDate is outside current displayed months, scroll to that month
        updateMonthYear(newDate);
        // setTimeout is required so focusing happens after the DOM has updated.
        setTimeout(() => {
            const elementToFocus = document.querySelector(`.${generateClassNameForDate(classNameId, newDate)}`);
            elementToFocus?.focus();
        }, 0);
    }, [updateMonthYear, classNameId]);
    useKey(ARROW_KEY_NAMES, handleArrowKey);
    const handleDateSelected = useCallback((d) => {
        if (isDateUnavailable?.(d))
            return;
        // Set current month/year to that of selected
        updateMonthYear(d);
        // Call parent callback
        onSelectDate?.(d);
    }, [isDateUnavailable, onSelectDate, updateMonthYear]);
    const renderProps = useDayzed({
        date: today,
        onDateSelected: ({ date }) => handleDateSelected(date),
        showOutsideDays: monthsToDisplay === 1,
        offset: getMonthOffsetFromToday(today, currMonth, currYear),
        onOffsetChanged,
        selected: !Array.isArray(selectedDates)
            ? selectedDates
            : selectedDates.filter(Boolean),
        monthsToDisplay: monthsToDisplay,
    });
    /**
     * Determines whether a given date should be in the tabbing sequence.
     * We only want one date at a time to be in the tabbing sequence.
     */
    const isDateFocusable = useCallback((d) => {
        // If there is a selected date in the current month, make it
        // the only focusable date
        if (dateToFocus &&
            inRange(dateToFocus.getMonth(), currMonth, currMonth + monthsToDisplay)) {
            return isSameDay(d, dateToFocus);
        }
        // If today is in the current month, make it the only focusable date
        // Use the latest today instead of memoised today since this doesn't affect
        // offset logic
        const currentToday = new Date();
        if (currentToday.getMonth() === currMonth) {
            return isSameDay(d, currentToday);
        }
        // If current month does not contain selected or today, make
        // first day focusable. We need to check that it corresponds with
        // currMonth or the spillover dates for the next month will be included.
        return d.getMonth() === currMonth && isFirstDayOfMonth(d);
    }, [dateToFocus, currMonth, monthsToDisplay]);
    return {
        isMobile,
        classNameId,
        currMonth,
        currYear,
        setCurrMonth,
        setCurrYear,
        renderProps,
        yearOptions,
        isDateUnavailable,
        selectedDates,
        onSelectDate,
        isDateFocusable,
        handleTodayClick,
        dateToFocus,
        onMouseEnterHighlight,
        onMouseLeaveCalendar,
        isDateInRange,
        hoveredDate,
        colorScheme,
        size,
        monthsToDisplay,
    };
};
