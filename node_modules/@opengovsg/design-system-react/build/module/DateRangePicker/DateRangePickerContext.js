import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useMemo, useRef, useState, } from 'react';
import { useControllableState, useDisclosure, useFormControlProps, useMultiStyleConfig, } from '@chakra-ui/react';
import { format, isValid, parse } from 'date-fns';
import { useIsMobile } from '../hooks/useIsMobile';
const DateRangePickerContext = createContext(null);
export const DateRangePickerProvider = ({ children, ...props }) => {
    const value = useProvideDateRangePicker(props);
    return (_jsx(DateRangePickerContext.Provider, { value: value, children: children }));
};
export const useDateRangePicker = () => {
    const context = useContext(DateRangePickerContext);
    if (!context) {
        throw new Error('useDateRangePicker must be used within a DateRangePickerProvider');
    }
    return context;
};
const useProvideDateRangePicker = ({ value, defaultValue = [null, null], onChange, labelSeparator = 'to', displayFormat = 'dd/MM/yyyy', dateFormat = 'dd/MM/yyyy', isDisabled: isDisabledProp, isReadOnly: isReadOnlyProp, isRequired: isRequiredProp, isInvalid: isInvalidProp, timeZone = 'UTC', locale, isDateUnavailable, allowManualInput = true, allowInvalidDates = true, closeCalendarOnChange = true, onBlur, onClick, colorScheme, monthsToDisplay, refocusOnClose = true, size, ssr, ...props }) => {
    const initialFocusRef = useRef(null);
    const startInputRef = useRef(null);
    const endInputRef = useRef(null);
    const isMobile = useIsMobile({ ssr });
    const disclosureProps = useDisclosure({
        onClose: () => {
            if (!refocusOnClose)
                return;
            // Refocus input after closing calendar.
            setTimeout(() => endInputRef.current?.focus(), 0);
        },
    });
    const [internalValue, setInternalValue] = useControllableState({
        defaultValue,
        value,
        onChange,
    });
    const [startDate, endDate] = internalValue;
    // What is rendered as a string in the start date range input according to given display format.
    const [startInputDisplay, setStartInputDisplay] = useState(startDate && isValid(startDate)
        ? format(startDate, displayFormat, { locale })
        : '');
    // What is rendered as a string in the end date range input according to given display format.
    const [endInputDisplay, setEndInputDisplay] = useState(endDate && isValid(endDate)
        ? format(endDate, displayFormat, { locale })
        : '');
    const handleUpdateInputs = useCallback((nextRange) => {
        const sortedRange = nextRange.sort((a, b) => a && b ? a.getTime() - b.getTime() : 0);
        // Replace invalid dates with null
        const validRange = sortedRange.map((date) => isValid(date) ? date : null);
        const [nextStart, nextEnd] = sortedRange;
        if (nextStart) {
            if (isValid(nextStart)) {
                setStartInputDisplay(format(nextStart, displayFormat, { locale }));
            }
            else if (!allowInvalidDates) {
                setStartInputDisplay('');
            }
        }
        else {
            setStartInputDisplay('');
        }
        if (nextEnd) {
            if (isValid(nextEnd)) {
                setEndInputDisplay(format(nextEnd, displayFormat, { locale }));
            }
            else if (!allowInvalidDates) {
                setEndInputDisplay('');
            }
        }
        else {
            setEndInputDisplay('');
        }
        setInternalValue(validRange);
    }, [allowInvalidDates, displayFormat, locale, setInternalValue, timeZone]);
    const fcProps = useFormControlProps({
        isInvalid: isInvalidProp,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        isRequired: isRequiredProp,
        ...props,
    });
    const handleInputBlur = useCallback((e) => {
        const startDate = parse(startInputDisplay, dateFormat, new Date());
        const endDate = parse(endInputDisplay, dateFormat, new Date());
        // Clear if input is invalid on blur if invalid dates are not allowed.
        if (!allowInvalidDates && !isValid(startDate)) {
            setStartInputDisplay('');
        }
        if (!allowInvalidDates && !isValid(endDate)) {
            setEndInputDisplay('');
        }
        handleUpdateInputs([startDate, endDate]);
        onBlur?.(e);
    }, [
        startInputDisplay,
        dateFormat,
        endInputDisplay,
        allowInvalidDates,
        handleUpdateInputs,
        onBlur,
    ]);
    const handleInputClick = useCallback((e) => {
        e.stopPropagation();
        if (!allowManualInput) {
            disclosureProps.onOpen();
        }
        onClick?.(e);
    }, [allowManualInput, disclosureProps, onClick]);
    const calendarButtonAria = useMemo(() => {
        let ariaLabel = 'Select from date picker. ';
        if (!startDate && !endDate)
            return ariaLabel + 'No date range selected.';
        if (startDate && !endDate) {
            if (isValid(startDate)) {
                ariaLabel += `Selected date is ${startDate.toDateString()}.`;
            }
            else {
                ariaLabel += 'Selected start date is invalid.';
            }
            // Both date range exists
        }
        else {
            ariaLabel += `Selected date range is ${startDate?.toDateString()} to ${endDate?.toDateString()}.`;
        }
        return ariaLabel;
    }, [endDate, startDate]);
    const handleStartDateChange = (event) => {
        const date = parse(event.target.value, dateFormat, new Date());
        setStartInputDisplay(event.target.value);
        let clonedValue = [...internalValue];
        if (!isValid(date)) {
            if (clonedValue.length > 0) {
                clonedValue = [null, null];
            }
        }
        else {
            clonedValue[0] = date;
        }
        setInternalValue(clonedValue);
    };
    const handleEndDateChange = (event) => {
        const date = parse(event.target.value, dateFormat, new Date());
        setEndInputDisplay(event.target.value);
        const [startDate, endDate] = internalValue;
        let clonedValue = [...internalValue];
        if (!isValid(date)) {
            if (startDate && endDate) {
                clonedValue = [startDate, null];
            }
        }
        else {
            clonedValue[1] = date;
        }
        setInternalValue(clonedValue);
    };
    const handleCalendarDateChange = useCallback((date) => {
        const [nextStartDate, nextEndDate] = date;
        setInternalValue(date);
        setStartInputDisplay(nextStartDate ? format(nextStartDate, displayFormat, { locale }) : '');
        setEndInputDisplay(nextEndDate ? format(nextEndDate, displayFormat, { locale }) : '');
        if (nextStartDate && nextEndDate && closeCalendarOnChange) {
            disclosureProps.onClose();
        }
    }, [
        closeCalendarOnChange,
        disclosureProps,
        displayFormat,
        locale,
        setInternalValue,
        timeZone,
    ]);
    const handleFieldContainerClick = useCallback(() => {
        if (allowManualInput) {
            startInputRef.current?.focus();
        }
        else {
            disclosureProps.onOpen();
        }
    }, [allowManualInput, disclosureProps]);
    const styles = useMultiStyleConfig('DateRangePicker', {
        size,
        colorScheme,
    });
    const placeholder = useMemo(() => displayFormat.toLowerCase(), [displayFormat]);
    return {
        isMobile,
        styles,
        handleCalendarDateChange,
        handleFieldContainerClick,
        handleStartDateChange,
        handleEndDateChange,
        handleInputClick,
        calendarButtonAria,
        startInputRef,
        endInputRef,
        initialFocusRef,
        handleInputBlur,
        fcProps,
        internalValue,
        startInputDisplay,
        endInputDisplay,
        closeCalendarOnChange,
        placeholder,
        allowManualInput,
        colorScheme,
        size,
        isDateUnavailable,
        disclosureProps,
        labelSeparator,
        monthsToDisplay,
    };
};
